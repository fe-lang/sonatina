; Memory optimization rules for sonatina IR
; NOTE: Requires types.egg and expr.egg to be loaded first

; === Must-Not-Alias Analysis ===
; Relation to determine if two addresses definitely don't alias
(relation must-not-alias (Expr Expr))

; Different allocas cannot alias
(rule ((= a1 (AllocaResult id1 ty1))
       (= a2 (AllocaResult id2 ty2))
       (!= id1 id2))
      ((must-not-alias a1 a2)
       (must-not-alias a2 a1)))

; Alloca cannot alias with global
(rule ((= a (AllocaResult _ _))
       (= g (Global _ _)))
      ((must-not-alias a g)
       (must-not-alias g a)))

; Different globals cannot alias
(rule ((= g1 (Global id1 _))
       (= g2 (Global id2 _))
       (!= id1 id2))
      ((must-not-alias g1 g2)
       (must-not-alias g2 g1)))

; GEP from non-aliasing bases don't alias
(rule ((= gep1 (GepBase base1))
       (= gep2 (GepBase base2))
       (must-not-alias base1 base2))
      ((must-not-alias gep1 gep2)
       (must-not-alias gep2 gep1)))

(rule ((= gep1 (GepOffset base1 _ _))
       (= gep2 (GepOffset base2 _ _))
       (must-not-alias base1 base2))
      ((must-not-alias gep1 gep2)
       (must-not-alias gep2 gep1)))

; GEP with same base but different constant indices don't alias
; e.g., gep v1 0 vs gep v1 1 (different array elements or struct fields)
(rule ((= gep1 (GepOffset base (Const c1 ty) field))
       (= gep2 (GepOffset base (Const c2 ty) field))
       (!= c1 c2))
      ((must-not-alias gep1 gep2)
       (must-not-alias gep2 gep1)))

; GEP with same base but different field indices don't alias
; This handles nested struct access where the field index differs
(rule ((= gep1 (GepOffset base idx1 field1))
       (= gep2 (GepOffset base idx2 field2))
       (!= field1 field2))
      ((must-not-alias gep1 gep2)
       (must-not-alias gep2 gep1)))

; === Store-to-Load Forwarding ===

; Load from a memory state after a store to the same address returns the stored value
; LoadResult(load_id, mem_id, ty) where:
;   - load-addr(load_id) == store-addr(mem_id)
;   - ty == store-ty(mem_id)
; Result: union LoadResult with store-val(mem_id)
(rule ((= result (LoadResult load_id mem_id ty))
       (= load_addr (load-addr load_id))
       (= store_addr (store-addr mem_id))
       (= load_addr store_addr)
       (= ty (store-ty mem_id))
       (= val (store-val mem_id)))
      ((union result val)))

; === Load Pass-Through ===

; Transitively walk through a chain of non-aliasing stores.
; If the current store cannot alias the load address, loading from this memory
; state is equivalent to loading from the previous memory state.
(rule ((= result (LoadResult load_id mem_id ty))
       (= load_addr (load-addr load_id))
       (= store_addr (store-addr mem_id))
       (must-not-alias store_addr load_addr)
       (= prev_mem_id (store-prev mem_id))
       )
      ((union result (LoadResult load_id prev_mem_id ty))))

; === Redundant Load Elimination ===

; Two loads from the same memory state at the same address should unify
(rule ((= r1 (LoadResult id1 mem_id ty))
       (= r2 (LoadResult id2 mem_id ty))
       (!= id1 id2)
       (= addr1 (load-addr id1))
       (= addr2 (load-addr id2))
       (= addr1 addr2))
      ((union r1 r2)))

; === MemPhi Rules ===

; Generic load merge through MemPhi.
; If every predecessor yields the same load result in the egraph, the MemPhi load
; is equivalent to that shared result.
(rule ((= result (LoadResult load_id memphi_id ty))
       (is-memphi memphi_id)
       (= 1 (memphi-num-preds memphi_id))
       (= pred_mem (memphi-pred memphi_id 0))
       )
      ((union result (LoadResult load_id pred_mem ty))))

(rule ((= result (LoadResult load_id memphi_id ty))
       (is-memphi memphi_id)
       (= 2 (memphi-num-preds memphi_id))
       (= pred0_mem (memphi-pred memphi_id 0))
       (= pred1_mem (memphi-pred memphi_id 1))
       )
      ((union (LoadResult load_id pred0_mem ty) (LoadResult load_id pred0_mem ty))
       (union (LoadResult load_id pred1_mem ty) (LoadResult load_id pred1_mem ty))))

(rule ((= result (LoadResult load_id memphi_id ty))
       (is-memphi memphi_id)
       (= 2 (memphi-num-preds memphi_id))
       (= pred0_mem (memphi-pred memphi_id 0))
       (= pred1_mem (memphi-pred memphi_id 1))
       (= r0 (LoadResult load_id pred0_mem ty))
       (= r1 (LoadResult load_id pred1_mem ty))
       (= r0 r1))
      ((union result r0)))

(rule ((= result (LoadResult load_id memphi_id ty))
       (is-memphi memphi_id)
       (= 3 (memphi-num-preds memphi_id))
       (= pred0_mem (memphi-pred memphi_id 0))
       (= pred1_mem (memphi-pred memphi_id 1))
       (= pred2_mem (memphi-pred memphi_id 2))
       )
      ((union (LoadResult load_id pred0_mem ty) (LoadResult load_id pred0_mem ty))
       (union (LoadResult load_id pred1_mem ty) (LoadResult load_id pred1_mem ty))
       (union (LoadResult load_id pred2_mem ty) (LoadResult load_id pred2_mem ty))))

(rule ((= result (LoadResult load_id memphi_id ty))
       (is-memphi memphi_id)
       (= 3 (memphi-num-preds memphi_id))
       (= pred0_mem (memphi-pred memphi_id 0))
       (= pred1_mem (memphi-pred memphi_id 1))
       (= pred2_mem (memphi-pred memphi_id 2))
       (= r0 (LoadResult load_id pred0_mem ty))
       (= r1 (LoadResult load_id pred1_mem ty))
       (= r2 (LoadResult load_id pred2_mem ty))
       (= r0 r1)
       (= r0 r2))
      ((union result r0)))

(rule ((= result (LoadResult load_id memphi_id ty))
       (is-memphi memphi_id)
       (= 4 (memphi-num-preds memphi_id))
       (= pred0_mem (memphi-pred memphi_id 0))
       (= pred1_mem (memphi-pred memphi_id 1))
       (= pred2_mem (memphi-pred memphi_id 2))
       (= pred3_mem (memphi-pred memphi_id 3))
       )
      ((union (LoadResult load_id pred0_mem ty) (LoadResult load_id pred0_mem ty))
       (union (LoadResult load_id pred1_mem ty) (LoadResult load_id pred1_mem ty))
       (union (LoadResult load_id pred2_mem ty) (LoadResult load_id pred2_mem ty))
       (union (LoadResult load_id pred3_mem ty) (LoadResult load_id pred3_mem ty))))

(rule ((= result (LoadResult load_id memphi_id ty))
       (is-memphi memphi_id)
       (= 4 (memphi-num-preds memphi_id))
       (= pred0_mem (memphi-pred memphi_id 0))
       (= pred1_mem (memphi-pred memphi_id 1))
       (= pred2_mem (memphi-pred memphi_id 2))
       (= pred3_mem (memphi-pred memphi_id 3))
       (= r0 (LoadResult load_id pred0_mem ty))
       (= r1 (LoadResult load_id pred1_mem ty))
       (= r2 (LoadResult load_id pred2_mem ty))
       (= r3 (LoadResult load_id pred3_mem ty))
       (= r0 r1)
       (= r0 r2)
       (= r0 r3))
      ((union result r0)))

; === Adjacent Dead Store Detection ===
; If a store immediately overwrites a previous store to the same address,
; the previous store is dead.
(relation dead-store (i64))
(rule ((= mem_id (store-prev next_mem_id))
       (!= mem_id 0)
       (= addr (store-addr next_mem_id))
       (= addr (store-addr mem_id)))
      ((dead-store mem_id)))
