; Memory optimization rules for sonatina IR
; NOTE: Requires types.egg and expr.egg to be loaded first

; === Must-Not-Alias Analysis ===
; Relation to determine if two addresses definitely don't alias
(relation must-not-alias (Expr Expr))

; Different allocas cannot alias
(rule ((= a1 (AllocaResult id1 ty1))
       (= a2 (AllocaResult id2 ty2))
       (!= id1 id2))
      ((must-not-alias a1 a2)
       (must-not-alias a2 a1)))

; Alloca cannot alias with global
(rule ((= a (AllocaResult _ _))
       (= g (Global _ _)))
      ((must-not-alias a g)
       (must-not-alias g a)))

; Different globals cannot alias
(rule ((= g1 (Global id1 _))
       (= g2 (Global id2 _))
       (!= id1 id2))
      ((must-not-alias g1 g2)
       (must-not-alias g2 g1)))

; GEP from non-aliasing bases don't alias
(rule ((= gep1 (GepBase base1))
       (= gep2 (GepBase base2))
       (must-not-alias base1 base2))
      ((must-not-alias gep1 gep2)
       (must-not-alias gep2 gep1)))

(rule ((= gep1 (GepOffset base1 _ _))
       (= gep2 (GepOffset base2 _ _))
       (must-not-alias base1 base2))
      ((must-not-alias gep1 gep2)
       (must-not-alias gep2 gep1)))

; === Store-to-Load Forwarding ===

; Load from a memory state after a store to the same address returns the stored value
; LoadResult(load_id, mem_id, ty) where:
;   - load-addr(load_id) == store-addr(mem_id)
;   - ty == store-ty(mem_id)
; Result: union LoadResult with store-val(mem_id)
(rule ((= result (LoadResult load_id mem_id ty))
       (= load_addr (load-addr load_id))
       (= store_addr (store-addr mem_id))
       (= load_addr store_addr)
       (= ty (store-ty mem_id))
       (= val (store-val mem_id)))
      ((union result val)))

; === Load Pass-Through ===

; Load from a memory state after a store to a different address
; can be unified with a load from the previous memory state
(rule ((= result (LoadResult load_id mem_id ty))
       (= load_addr (load-addr load_id))
       (= store_addr (store-addr mem_id))
       (must-not-alias store_addr load_addr)
       (= prev_mem_id (store-prev mem_id))
       (= prev_result (LoadResult prev_load_id prev_mem_id ty))
       (= prev_load_addr (load-addr prev_load_id))
       (= prev_load_addr load_addr))
      ((union result prev_result)))

; === Redundant Load Elimination ===

; Two loads from the same memory state at the same address should unify
(rule ((= r1 (LoadResult id1 mem_id ty))
       (= r2 (LoadResult id2 mem_id ty))
       (!= id1 id2)
       (= addr1 (load-addr id1))
       (= addr2 (load-addr id2))
       (= addr1 addr2))
      ((union r1 r2)))