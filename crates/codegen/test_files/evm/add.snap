---
source: crates/codegen/tests/evm.rs
expression: "String::from_utf8(out).unwrap()"
input_file: test_files/evm/add.sntn
---
evm.config: stack_reach=16 emit_debug_trace=true

object: Contract
  section runtime: 31 bytes
  total: 31 bytes

functions:
  mem: dyn_base=0xc0 static_base=0xc0
  entry: ir_blocks=1 ir_insts=7 vcode_ops=21 fixups=2 imm_bytes=4
    mem: sa{n:0,l:0}
  add: ir_blocks=1 ir_insts=2 vcode_ops=4 fixups=0 imm_bytes=0
    mem: sa{n:0,l:0}

evm:
  case ok: calldata_len=8 success reason=Return gas_used=21132 gas_refunded=0 logs=0 output=call len=32


--------------- DEBUG ---------------

evm mem plan: dyn_base=0xc0 static_base=0xc0
evm mem plan: entry sa{n:0,l:0}
evm mem plan: add sa{n:0,l:0}

// func public %entry()
  block0 P=[] T=[]
    - stack=[]
      pre: [PUSH(0)]
      evm_calldata_load [0] -> v0
    - stack=[v0]
      pre: [DUP1, PUSH(224)]
      shr [224, v0] -> v1
    - stack=[v1, v0], last_use=[v0]
      pre: [SWAP1, PUSH(32)]
      shl [32, v0] -> v2
    - stack=[v2, v1], last_use=[v2]
      pre: [PUSH(224)]
      shr [224, v2] -> v3
    - stack=[v3, v1], last_use=[v1, v3]
      pre: [PUSH_CONT, SWAP2]
      call [v3, v1] -> v4
    - stack=[v4], last_use=[v4]
      pre: [PUSH(0)]
      mstore [0, v4]
    - stack=[]
      pre: [PUSH(32), PUSH(0)]
      evm_return [0, 32]

// func public %add(v0.i32, v1.i32) -> i32
  block0 P=[v0, v1] T=[]
    - stack=[v0, v1, <RET>], last_use=[v0, v1]
      add [v0, v1] -> v2
    - stack=[v2, <RET>]
      return [v2]

// func public %entry()
entry:
  block0:
    JUMPDEST
    PUSH0  // v0.i256 = evm_calldata_load 0.i32;
    CALLDATALOAD
    DUP1  // v1.i32 = shr 224.i32 v0;
    PUSH1 0xe0 (224)
    SHR
    SWAP1  // v2.i32 = shl 32.i32 v0;
    PUSH1 0x20 (32)
    SHL
    PUSH1 0xe0 (224)  // v3.i32 = shr 224.i32 v2;
    SHR
    PUSH1 `pc + (4)`  // v4.i32 = call %add v1 v3;
    SWAP2
    PUSH1 FuncRef(1)
    JUMP
    JUMPDEST
    PUSH0  // mstore 0.i32 v4 i32;
    MSTORE
    PUSH1 0x20 (32)  // evm_return 0.i8 32.i8;
    PUSH0
    RETURN

// func public %add(v0.i32, v1.i32) -> i32
add:
  block0:
    JUMPDEST
    ADD  // v2.i32 = add v0 v1;
    SWAP1  // return v2;
    JUMP



--------------- BYTECODE ---------------

// section runtime
0x5b5f358060e01c9060201b60e01c601491601b565b5f5260205ff35b019056
