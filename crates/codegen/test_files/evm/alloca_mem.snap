---
source: crates/codegen/tests/evm.rs
expression: "String::from_utf8(v).unwrap()"
input_file: test_files/evm/alloca_mem.sntn
---
evm mem plan: dyn_base=0xe0 static_base=0xc0
evm mem plan: helper scheme=StaticTree base_words=0 persistent_words=0 alloca_words=0 persistent_alloca_words=0
evm mem plan: main scheme=StaticTree base_words=0 persistent_words=0 alloca_words=1 persistent_alloca_words=0
  alloca v0 class=Transient offset_words=0 size_words=1 addr=0xc0
  alloca v4 class=Transient offset_words=0 size_words=1 addr=0xc0
  alloca v6 class=Transient offset_words=0 size_words=1 addr=0xc0
evm mem plan: entry scheme=StaticTree base_words=0 persistent_words=0 alloca_words=0 persistent_alloca_words=0

// func public %helper() -> i256
  block0 P=[] T=[]
    - stack=[<RET>]
      return: [PUSH(I256 { is_negative: false, abs: 7 })]
      return [I256 { is_negative: false, abs: 7 }]

// func public %main() -> i256
spill_set: 0=v0
  block0 P=[] T=[]
    - stack=[<RET>]
      alloca [] -> v0
      post: [DUP1, MSTORE_SLOT(0)]
    - stack=[v0, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 11 }), DUP2]
      mstore [v0, I256 { is_negative: false, abs: 11 }]
    - stack=[v0, <RET>]
      pre: [DUP1]
      mload [v0] -> v1
    - stack=[v1x, v0, <RET>]
      cleanup: [POP]
      pre: [PUSH_CONT]
      call [] -> v2
    - stack=[v2, v0, <RET>], last_use=[v2]
      pre: [DUP2]
      mstore [v0, v2]
    - stack=[v0, <RET>], last_use=[v0]
      mload [v0] -> v3
    - stack=[v3, <RET>]
      alloca [] -> v4
    - stack=[v4, v3, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 1 }), DUP2]
      mstore [v4, I256 { is_negative: false, abs: 1 }]
    - stack=[v4, v3, <RET>], last_use=[v4]
      mload [v4] -> v5
    - stack=[v5, v3, <RET>]
      alloca [] -> v6
    - stack=[v6, v5, v3, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 2 }), DUP2]
      mstore [v6, I256 { is_negative: false, abs: 2 }]
    - stack=[v6, v5, v3, <RET>], last_use=[v6]
      mload [v6] -> v7
    - stack=[v7, v5, v3, <RET>], last_use=[v3, v5]
      pre: [SWAP2]
      add [v3, v5] -> v8
    - stack=[v8, v7, <RET>], last_use=[v7, v8]
      add [v8, v7] -> v9
    - stack=[v9, <RET>]
      return [v9]

// func public %entry()
  block0 P=[] T=[]
    - stack=[]
      pre: [PUSH_CONT]
      call [] -> v0
    - stack=[v0], last_use=[v0]
      pre: [PUSH(0)]
      mstore [0, v0]
    - stack=[]
      pre: [PUSH(32), PUSH(0)]
      evm_return [0, 32]

// func public %helper() -> i256
helper:
  block0:
    JUMPDEST
    PUSH1 0x7 (7)  // return 7.i256;
    SWAP1
    JUMP

// func public %main() -> i256
main:
  block0:
    JUMPDEST
    PUSH1 0xc0 (192)  // v0.*i256 = alloca i256;
    DUP1
    PUSH0
    MSTORE
    PUSH1 0xb (11)  // mstore v0 11.i256 i256;
    DUP2
    MSTORE
    DUP1  // v1.i256 = mload v0 i256;
    MLOAD
    POP  // v2.i256 = call %helper;
    PUSH1 `pc + (3)`
    PUSH1 FuncRef(0)
    JUMP
    JUMPDEST
    DUP2  // mstore v0 v2 i256;
    MSTORE
    MLOAD  // v3.i256 = mload v0 i256;
    PUSH1 0xc0 (192)  // v4.*i256 = alloca i256;
    PUSH1 0x1 (1)  // mstore v4 1.i256 i256;
    DUP2
    MSTORE
    MLOAD  // v5.i256 = mload v4 i256;
    PUSH1 0xc0 (192)  // v6.*i256 = alloca i256;
    PUSH1 0x2 (2)  // mstore v6 2.i256 i256;
    DUP2
    MSTORE
    MLOAD  // v7.i256 = mload v6 i256;
    SWAP2  // v8.i256 = add v3 v5;
    ADD
    ADD  // v9.i256 = add v8 v7;
    SWAP1  // return v9;
    JUMP

// func public %entry()
entry:
  block0:
    JUMPDEST
    PUSH1 `pc + (3)`  // v0.i256 = call %main;
    PUSH1 FuncRef(1)
    JUMP
    JUMPDEST
    PUSH0  // mstore 0.i32 v0 i256;
    MSTORE
    PUSH1 0x20 (32)  // evm_return 0.i8 32.i8;
    PUSH0
    RETURN



---------------

// section runtime
0x5b6006600d565b5f5260205ff35b60c0805f52600b8152805150601f6036565b81525160c0600181525160c0600281525191010190565b60079056


Success { reason: Return, gas_used: 21221, gas_refunded: 0, logs: [], output: Call(0x000000000000000000000000000000000000000000000000000000000000000a) }

    pc  opcode            input (stack grows to the right)
     0  5b  JUMPDEST      []
     1  60  PUSH1         0x06  []
     3  60  PUSH1         0x0d  [0x6]
     5  56  JUMP          [0x6, 0xd]
    13  5b  JUMPDEST      [0x6]
    14  60  PUSH1         0xc0  [0x6]
    16  80  DUP1          [0x6, 0xc0]
    17  5f  PUSH0         [0x6, 0xc0, 0xc0]
    18  52  MSTORE        [0x6, 0xc0, 0xc0, 0x0]
    19  60  PUSH1         0x0b  [0x6, 0xc0]
    21  81  DUP2          [0x6, 0xc0, 0xb]
    22  52  MSTORE        [0x6, 0xc0, 0xb, 0xc0]
    23  80  DUP1          [0x6, 0xc0]
    24  51  MLOAD         [0x6, 0xc0, 0xc0]
    25  50  POP           [0x6, 0xc0, 0xb]
    26  60  PUSH1         0x1f  [0x6, 0xc0]
    28  60  PUSH1         0x36  [0x6, 0xc0, 0x1f]
    30  56  JUMP          [0x6, 0xc0, 0x1f, 0x36]
    54  5b  JUMPDEST      [0x6, 0xc0, 0x1f]
    55  60  PUSH1         0x07  [0x6, 0xc0, 0x1f]
    57  90  SWAP1         [0x6, 0xc0, 0x1f, 0x7]
    58  56  JUMP          [0x6, 0xc0, 0x7, 0x1f]
    31  5b  JUMPDEST      [0x6, 0xc0, 0x7]
    32  81  DUP2          [0x6, 0xc0, 0x7]
    33  52  MSTORE        [0x6, 0xc0, 0x7, 0xc0]
    34  51  MLOAD         [0x6, 0xc0]
    35  60  PUSH1         0xc0  [0x6, 0x7]
    37  60  PUSH1         0x01  [0x6, 0x7, 0xc0]
    39  81  DUP2          [0x6, 0x7, 0xc0, 0x1]
    40  52  MSTORE        [0x6, 0x7, 0xc0, 0x1, 0xc0]
    41  51  MLOAD         [0x6, 0x7, 0xc0]
    42  60  PUSH1         0xc0  [0x6, 0x7, 0x1]
    44  60  PUSH1         0x02  [0x6, 0x7, 0x1, 0xc0]
    46  81  DUP2          [0x6, 0x7, 0x1, 0xc0, 0x2]
    47  52  MSTORE        [0x6, 0x7, 0x1, 0xc0, 0x2, 0xc0]
    48  51  MLOAD         [0x6, 0x7, 0x1, 0xc0]
    49  91  SWAP2         [0x6, 0x7, 0x1, 0x2]
    50  01  ADD           [0x6, 0x2, 0x1, 0x7]
    51  01  ADD           [0x6, 0x2, 0x8]
    52  90  SWAP1         [0x6, 0xa]
    53  56  JUMP          [0xa, 0x6]
     6  5b  JUMPDEST      [0xa]
     7  5f  PUSH0         [0xa]
     8  52  MSTORE        [0xa, 0x0]
     9  60  PUSH1         0x20  []
    11  5f  PUSH0         [0x20]
    12  f3  RETURN        [0x20, 0x0]
