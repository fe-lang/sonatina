---
source: crates/codegen/tests/evm.rs
expression: "String::from_utf8(out).unwrap()"
input_file: test_files/evm/coin.sntn
---
evm.config: stack_reach=16 emit_debug_trace=true opt_pipeline=aggressive

object: Contract
  section runtime: 3588 bytes
  section coin_init: 1411 bytes
  section coin_runtime: 1066 bytes
  total: 6065 bytes

functions:
  mem: dyn_base=0xc0 static_base=0xc0
  test_coin__StorPtr_Evm___207f35a85ac4062e: ir_blocks=1 ir_insts=74 vcode_ops=400 fixups=48 imm_bytes=64
    mem: sa{n:0,l:0} malloc{n:4,fsb:0,t:0,e:0,const_wrds:8,dyn_cnt:0}
  __Coin_recv_0_0: ir_blocks=3 ir_insts=35 vcode_ops=73 fixups=1 imm_bytes=11
    mem: sa{n:0,l:0}
  __Coin_recv_0_1: ir_blocks=7 ir_insts=45 vcode_ops=107 fixups=3 imm_bytes=13
    mem: sa{n:0,l:0}
  __Coin_recv_0_2: ir_blocks=3 ir_insts=9 vcode_ops=18 fixups=1 imm_bytes=3
    mem: sa{n:0,l:0}
  __Coin_init: ir_blocks=3 ir_insts=36 vcode_ops=168 fixups=13 imm_bytes=20
    mem: sa{n:0,l:0} malloc{n:2,fsb:0,t:0,e:1,const_wrds:2,dyn_cnt:1}
  __Coin_runtime: ir_blocks=9 ir_insts=93 vcode_ops=446 fixups=50 imm_bytes=44
    mem: sa{n:0,l:0} malloc{n:5,fsb:0,t:4,e:0,const_wrds:11,dyn_cnt:0}
  create2__Evm_hef0af3106e109414_Coin_h690a60df6720eb85__139b6eceaab4e08e: ir_blocks=3 ir_insts=32 vcode_ops=169 fixups=15 imm_bytes=20
    mem: sa{n:0,l:0} malloc{n:3,fsb:0,t:2,e:1,const_wrds:3,dyn_cnt:2}
  assert: ir_blocks=3 ir_insts=7 vcode_ops=14 fixups=1 imm_bytes=1
    mem: sa{n:0,l:0}
  evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__Credit_h1b40c7da4bcceeac__9489dcd0a297a0c: ir_blocks=3 ir_insts=46 vcode_ops=181 fixups=17 imm_bytes=18
    mem: sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:0,const_wrds:0,dyn_cnt:1}
  evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__Transfer_hbe7d801e15d910f6__66cc42efa72ff9b1: ir_blocks=3 ir_insts=46 vcode_ops=181 fixups=17 imm_bytes=18
    mem: sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:0,const_wrds:0,dyn_cnt:1}
  evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__BalanceOf_h891837b06b5610d4__9cd8cdf578aad9be: ir_blocks=3 ir_insts=37 vcode_ops=158 fixups=15 imm_bytes=16
    mem: sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:0,const_wrds:0,dyn_cnt:1}
  evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__TotalSupply_h7bb395110a25abc2__8d4065b5d6bedb33: ir_blocks=3 ir_insts=36 vcode_ops=147 fixups=13 imm_bytes=16
    mem: sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:0,const_wrds:0,dyn_cnt:1}
  alloc: ir_blocks=10 ir_insts=30 vcode_ops=60 fixups=6 imm_bytes=8
    mem: sa{n:0,l:0}
  runtime_selector__Evm_hef0af3106e109414_Sol_hfd482bb803ad8c5f__e4e3f8d20b3805a2: ir_blocks=3 ir_insts=10 vcode_ops=22 fixups=1 imm_bytes=3
    mem: sa{n:0,l:0}
  return_value__Evm_hef0af3106e109414_Sol_hfd482bb803ad8c5f_u256__c4b26908c66ef75f: ir_blocks=1 ir_insts=22 vcode_ops=67 fixups=6 imm_bytes=8
    mem: sa{n:0,l:0}
  decode_returndata__u256__3271ca15373d4483: ir_blocks=3 ir_insts=21 vcode_ops=101 fixups=9 imm_bytes=13
    mem: sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:0,const_wrds:2,dyn_cnt:0}
  soldecoder_i__ha12a03fcb5ba844b_new__MemoryBytes_h1e381015a9b0111b__59e0d528d54cca1b: ir_blocks=1 ir_insts=53 vcode_ops=238 fixups=8 imm_bytes=30
    mem: sa{n:0,l:0} malloc{n:2,fsb:0,t:0,e:1,const_wrds:7,dyn_cnt:0}
  u256_h3271ca15373d4483_encode_hab7243eccf2714fb_encode__Sol_hfd482bb803ad8c5f_SolEncoder_h1b9228b90dad6928__1a070c3866d16383: ir_blocks=1 ir_insts=11 vcode_ops=29 fixups=0 imm_bytes=5
    mem: sa{n:0,l:0}
  solencoder_h1b9228b90dad6928_abiencoder_hffd58d20d4321024_finish: ir_blocks=1 ir_insts=20 vcode_ops=88 fixups=4 imm_bytes=11
    mem: sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:1,const_wrds:2,dyn_cnt:0}
  solencoder_h1b9228b90dad6928_new: ir_blocks=1 ir_insts=15 vcode_ops=80 fixups=4 imm_bytes=11
    mem: sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:1,const_wrds:3,dyn_cnt:0}
  cursor_i__h140a998c67d6d59c_new__MemoryBytes_h1e381015a9b0111b__59e0d528d54cca1b: ir_blocks=1 ir_insts=23 vcode_ops=102 fixups=4 imm_bytes=13
    mem: sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:1,const_wrds:3,dyn_cnt:0}
  soldecoder_i__ha12a03fcb5ba844b_with_base__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563: ir_blocks=1 ir_insts=47 vcode_ops=238 fixups=12 imm_bytes=28
    mem: sa{n:0,l:0} malloc{n:3,fsb:0,t:1,e:1,const_wrds:7,dyn_cnt:0}
  soldecoder_i__ha12a03fcb5ba844b_abidecoder_h638151350e80a086_read_word__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563: ir_blocks=3 ir_insts=57 vcode_ops=147 fixups=1 imm_bytes=12
    mem: sa{n:0,l:0}
  solencoder_h1b9228b90dad6928_ensure_init: ir_blocks=4 ir_insts=27 vcode_ops=103 fixups=6 imm_bytes=11
    mem: sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:1,const_wrds:0,dyn_cnt:1}
  soldecoder_i__ha12a03fcb5ba844b_abidecoder_h638151350e80a086_read_word__MemoryBytes_h1e381015a9b0111b__59e0d528d54cca1b: ir_blocks=3 ir_insts=61 vcode_ops=159 fixups=1 imm_bytes=14
    mem: sa{n:0,l:0}
  cursor_i__h140a998c67d6d59c_new__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563: ir_blocks=1 ir_insts=11 vcode_ops=68 fixups=4 imm_bytes=9
    mem: sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:1,const_wrds:2,dyn_cnt:0}
  cursor_i__h140a998c67d6d59c_fork__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563: ir_blocks=1 ir_insts=15 vcode_ops=77 fixups=4 imm_bytes=9
    mem: sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:1,const_wrds:2,dyn_cnt:0}

evm:
  case ok: calldata_len=0 success reason=Return gas_used=363976 gas_refunded=0 logs=0 output=call len=0


--------------- DEBUG ---------------

evm mem plan: dyn_base=0xc0 static_base=0xc0
evm mem plan: test_coin__StorPtr_Evm___207f35a85ac4062e sa{n:0,l:0} malloc{n:4,fsb:0,t:0,e:0,const_wrds:8,dyn_cnt:0}
evm mem plan: __Coin_recv_0_0 sa{n:0,l:0}
evm mem plan: __Coin_recv_0_1 sa{n:0,l:0}
evm mem plan: __Coin_recv_0_2 sa{n:0,l:0}
evm mem plan: __Coin_init sa{n:0,l:0} malloc{n:2,fsb:0,t:0,e:1,const_wrds:2,dyn_cnt:1}
evm mem plan: __Coin_runtime sa{n:0,l:0} malloc{n:5,fsb:0,t:4,e:0,const_wrds:11,dyn_cnt:0}
evm mem plan: create2__Evm_hef0af3106e109414_Coin_h690a60df6720eb85__139b6eceaab4e08e sa{n:0,l:0} malloc{n:3,fsb:0,t:2,e:1,const_wrds:3,dyn_cnt:2}
evm mem plan: assert sa{n:0,l:0}
evm mem plan: evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__Credit_h1b40c7da4bcceeac__9489dcd0a297a0c sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:0,const_wrds:0,dyn_cnt:1}
evm mem plan: evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__Transfer_hbe7d801e15d910f6__66cc42efa72ff9b1 sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:0,const_wrds:0,dyn_cnt:1}
evm mem plan: evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__BalanceOf_h891837b06b5610d4__9cd8cdf578aad9be sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:0,const_wrds:0,dyn_cnt:1}
evm mem plan: evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__TotalSupply_h7bb395110a25abc2__8d4065b5d6bedb33 sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:0,const_wrds:0,dyn_cnt:1}
evm mem plan: alloc sa{n:0,l:0}
evm mem plan: runtime_selector__Evm_hef0af3106e109414_Sol_hfd482bb803ad8c5f__e4e3f8d20b3805a2 sa{n:0,l:0}
evm mem plan: return_value__Evm_hef0af3106e109414_Sol_hfd482bb803ad8c5f_u256__c4b26908c66ef75f sa{n:0,l:0}
evm mem plan: decode_returndata__u256__3271ca15373d4483 sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:0,const_wrds:2,dyn_cnt:0}
evm mem plan: soldecoder_i__ha12a03fcb5ba844b_new__MemoryBytes_h1e381015a9b0111b__59e0d528d54cca1b sa{n:0,l:0} malloc{n:2,fsb:0,t:0,e:1,const_wrds:7,dyn_cnt:0}
evm mem plan: u256_h3271ca15373d4483_encode_hab7243eccf2714fb_encode__Sol_hfd482bb803ad8c5f_SolEncoder_h1b9228b90dad6928__1a070c3866d16383 sa{n:0,l:0}
evm mem plan: solencoder_h1b9228b90dad6928_abiencoder_hffd58d20d4321024_finish sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:1,const_wrds:2,dyn_cnt:0}
evm mem plan: solencoder_h1b9228b90dad6928_new sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:1,const_wrds:3,dyn_cnt:0}
evm mem plan: cursor_i__h140a998c67d6d59c_new__MemoryBytes_h1e381015a9b0111b__59e0d528d54cca1b sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:1,const_wrds:3,dyn_cnt:0}
evm mem plan: soldecoder_i__ha12a03fcb5ba844b_with_base__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563 sa{n:0,l:0} malloc{n:3,fsb:0,t:1,e:1,const_wrds:7,dyn_cnt:0}
evm mem plan: soldecoder_i__ha12a03fcb5ba844b_abidecoder_h638151350e80a086_read_word__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563 sa{n:0,l:0}
evm mem plan: solencoder_h1b9228b90dad6928_ensure_init sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:1,const_wrds:0,dyn_cnt:1}
evm mem plan: soldecoder_i__ha12a03fcb5ba844b_abidecoder_h638151350e80a086_read_word__MemoryBytes_h1e381015a9b0111b__59e0d528d54cca1b sa{n:0,l:0}
evm mem plan: cursor_i__h140a998c67d6d59c_new__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563 sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:1,const_wrds:2,dyn_cnt:0}
evm mem plan: cursor_i__h140a998c67d6d59c_fork__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563 sa{n:0,l:0} malloc{n:1,fsb:0,t:0,e:1,const_wrds:2,dyn_cnt:0}

// func private %test_coin__StorPtr_Evm___207f35a85ac4062e()
  block0 P=[] T=[]
    - stack=[]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH_CONT, SWAP2]
      call [I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v0
    - stack=[v0]
      pre: [DUP1]
      is_zero [v0] -> v69
    - stack=[v69, v0], last_use=[v69]
      is_zero [v69] -> v70
    - stack=[v70, v0], last_use=[v70]
      zext [v70] -> v3
    - stack=[v3, v0], last_use=[v3]
      pre: [PUSH_CONT, SWAP1]
      call [v3]
    - stack=[v0]
      pre: [PUSH(I256 { is_negative: false, abs: 64 })]
      evm_malloc [I256 { is_negative: false, abs: 64 }] -> v4
    - stack=[v4, v0], last_use=[v4]
      ptr_to_int [v4] -> v5
    - stack=[v5, v0]
      pre: [DUP1]
      int_to_ptr [v5] -> v6
    - stack=[v6, v5, v0], last_use=[v6]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v6, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v7
    - stack=[v7, v5, v0], last_use=[v7]
      ptr_to_int [v7] -> v8
    - stack=[v8, v5, v0], last_use=[v8]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), SWAP1]
      mstore [v8, I256 { is_negative: false, abs: 0 }]
    - stack=[v5, v0]
      pre: [DUP1]
      int_to_ptr [v5] -> v9
    - stack=[v9, v5, v0], last_use=[v9]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v9, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v10
    - stack=[v10, v5, v0], last_use=[v10]
      ptr_to_int [v10] -> v11
    - stack=[v11, v5, v0], last_use=[v11]
      pre: [PUSH(I256 { is_negative: false, abs: 10 }), SWAP1]
      mstore [v11, I256 { is_negative: false, abs: 10 }]
    - stack=[v5, v0], last_use=[v5]
      pre: [DUP2, SWAP1, PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 100000 }), PUSH_CONT, SWAP4]
      call [I256 { is_negative: false, abs: 100000 }, I256 { is_negative: false, abs: 0 }, v5, v0] -> v12
    - stack=[v12, v0], last_use=[v12]
      pre: [PUSH(I256 { is_negative: false, abs: 10 })]
      eq [I256 { is_negative: false, abs: 10 }, v12] -> v71
    - stack=[v71, v0], last_use=[v71]
      zext [v71] -> v14
    - stack=[v14, v0], last_use=[v14]
      pre: [PUSH_CONT, SWAP1]
      call [v14]
    - stack=[v0]
      pre: [PUSH(I256 { is_negative: false, abs: 64 })]
      evm_malloc [I256 { is_negative: false, abs: 64 }] -> v15
    - stack=[v15, v0], last_use=[v15]
      ptr_to_int [v15] -> v16
    - stack=[v16, v0]
      pre: [DUP1]
      int_to_ptr [v16] -> v17
    - stack=[v17, v16, v0], last_use=[v17]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v17, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v18
    - stack=[v18, v16, v0], last_use=[v18]
      ptr_to_int [v18] -> v19
    - stack=[v19, v16, v0], last_use=[v19]
      pre: [PUSH(I256 { is_negative: false, abs: 1 }), SWAP1]
      mstore [v19, I256 { is_negative: false, abs: 1 }]
    - stack=[v16, v0]
      pre: [DUP1]
      int_to_ptr [v16] -> v20
    - stack=[v20, v16, v0], last_use=[v20]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v20, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v21
    - stack=[v21, v16, v0], last_use=[v21]
      ptr_to_int [v21] -> v22
    - stack=[v22, v16, v0], last_use=[v22]
      pre: [PUSH(I256 { is_negative: false, abs: 5 }), SWAP1]
      mstore [v22, I256 { is_negative: false, abs: 5 }]
    - stack=[v16, v0], last_use=[v16]
      pre: [DUP2, SWAP1, PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 100000 }), PUSH_CONT, SWAP4]
      call [I256 { is_negative: false, abs: 100000 }, I256 { is_negative: false, abs: 0 }, v16, v0] -> v23
    - stack=[v23, v0], last_use=[v23]
      pre: [PUSH(I256 { is_negative: false, abs: 5 })]
      eq [I256 { is_negative: false, abs: 5 }, v23] -> v72
    - stack=[v72, v0], last_use=[v72]
      zext [v72] -> v25
    - stack=[v25, v0], last_use=[v25]
      pre: [PUSH_CONT, SWAP1]
      call [v25]
    - stack=[v0]
      pre: [PUSH(I256 { is_negative: false, abs: 64 })]
      evm_malloc [I256 { is_negative: false, abs: 64 }] -> v26
    - stack=[v26, v0], last_use=[v26]
      ptr_to_int [v26] -> v27
    - stack=[v27, v0]
      pre: [DUP1]
      int_to_ptr [v27] -> v28
    - stack=[v28, v27, v0], last_use=[v28]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v28, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v29
    - stack=[v29, v27, v0], last_use=[v29]
      ptr_to_int [v29] -> v30
    - stack=[v30, v27, v0], last_use=[v30]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), SWAP1]
      mstore [v30, I256 { is_negative: false, abs: 0 }]
    - stack=[v27, v0]
      pre: [DUP1]
      int_to_ptr [v27] -> v31
    - stack=[v31, v27, v0], last_use=[v31]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v31, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v32
    - stack=[v32, v27, v0], last_use=[v32]
      ptr_to_int [v32] -> v33
    - stack=[v33, v27, v0], last_use=[v33]
      pre: [PUSH(I256 { is_negative: false, abs: 3 }), SWAP1]
      mstore [v33, I256 { is_negative: false, abs: 3 }]
    - stack=[v27, v0], last_use=[v27]
      pre: [DUP2, SWAP1, PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 100000 }), PUSH_CONT, SWAP4]
      call [I256 { is_negative: false, abs: 100000 }, I256 { is_negative: false, abs: 0 }, v27, v0] -> v34
    - stack=[v34, v0], last_use=[v34]
      is_zero [v34] -> v73
    - stack=[v73, v0], last_use=[v73]
      zext [v73] -> v36
    - stack=[v36, v0], last_use=[v36]
      pre: [PUSH_CONT, SWAP1]
      call [v36]
    - stack=[v0]
      pre: [DUP1, PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 100000 }), PUSH_CONT, SWAP4]
      call [I256 { is_negative: false, abs: 100000 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, v0] -> v37
    - stack=[v37, v0], last_use=[v37]
      pre: [PUSH(I256 { is_negative: false, abs: 7 })]
      eq [I256 { is_negative: false, abs: 7 }, v37] -> v74
    - stack=[v74, v0], last_use=[v74]
      zext [v74] -> v39
    - stack=[v39, v0], last_use=[v39]
      pre: [PUSH_CONT, SWAP1]
      call [v39]
    - stack=[v0]
      pre: [DUP1, PUSH(I256 { is_negative: false, abs: 1 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 100000 }), PUSH_CONT, SWAP4]
      call [I256 { is_negative: false, abs: 100000 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }, v0] -> v40
    - stack=[v40, v0], last_use=[v40]
      pre: [PUSH(I256 { is_negative: false, abs: 8 })]
      eq [I256 { is_negative: false, abs: 8 }, v40] -> v75
    - stack=[v75, v0], last_use=[v75]
      zext [v75] -> v42
    - stack=[v42, v0], last_use=[v42]
      pre: [PUSH_CONT, SWAP1]
      call [v42]
    - stack=[v0]
      pre: [PUSH(I256 { is_negative: false, abs: 64 })]
      evm_malloc [I256 { is_negative: false, abs: 64 }] -> v43
    - stack=[v43, v0], last_use=[v43]
      ptr_to_int [v43] -> v44
    - stack=[v44, v0]
      pre: [DUP1]
      int_to_ptr [v44] -> v45
    - stack=[v45, v44, v0], last_use=[v45]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v45, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v46
    - stack=[v46, v44, v0], last_use=[v46]
      ptr_to_int [v46] -> v47
    - stack=[v47, v44, v0], last_use=[v47]
      pre: [PUSH(I256 { is_negative: false, abs: 1 }), SWAP1]
      mstore [v47, I256 { is_negative: false, abs: 1 }]
    - stack=[v44, v0]
      pre: [DUP1]
      int_to_ptr [v44] -> v48
    - stack=[v48, v44, v0], last_use=[v48]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v48, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v49
    - stack=[v49, v44, v0], last_use=[v49]
      ptr_to_int [v49] -> v50
    - stack=[v50, v44, v0], last_use=[v50]
      pre: [PUSH(I256 { is_negative: false, abs: 20 }), SWAP1]
      mstore [v50, I256 { is_negative: false, abs: 20 }]
    - stack=[v44, v0], last_use=[v44]
      pre: [DUP2, SWAP1, PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 100000 }), PUSH_CONT, SWAP4]
      call [I256 { is_negative: false, abs: 100000 }, I256 { is_negative: false, abs: 0 }, v44, v0] -> v51
    - stack=[v51, v0], last_use=[v51]
      pre: [PUSH(I256 { is_negative: false, abs: 1 })]
      eq [I256 { is_negative: false, abs: 1 }, v51] -> v76
    - stack=[v76, v0], last_use=[v76]
      zext [v76] -> v53
    - stack=[v53, v0], last_use=[v53]
      pre: [PUSH_CONT, SWAP1]
      call [v53]
    - stack=[v0], last_use=[v0]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 100000 }), PUSH_CONT, SWAP3]
      call [I256 { is_negative: false, abs: 100000 }, I256 { is_negative: false, abs: 0 }, v0] -> v54
    - stack=[v54], last_use=[v54]
      pre: [PUSH(I256 { is_negative: false, abs: 15 })]
      eq [I256 { is_negative: false, abs: 15 }, v54] -> v77
    - stack=[v77], last_use=[v77]
      zext [v77] -> v56
    - stack=[v56], last_use=[v56]
      pre: [PUSH_CONT, SWAP1]
      call [v56]
    - stack=[]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 })]
      evm_return [I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }]

// func private %__Coin_recv_0_0(v0.i256, v1.i256) -> i256
  block0 P=[v0, v1] T=[]
    - stack=[v0, v1, <RET>]
      pre: [DUP1]
      int_to_ptr [v0] -> v2
    - stack=[v2, v0, v1, <RET>], last_use=[v2]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v2, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v3
    - stack=[v3, v0, v1, <RET>], last_use=[v3]
      ptr_to_int [v3] -> v4
    - stack=[v4, v0, v1, <RET>], last_use=[v4]
      mload [v4] -> v5
    - stack=[v5, v0, v1, <RET>], last_use=[v0]
      pre: [SWAP1]
      int_to_ptr [v0] -> v6
    - stack=[v6, v5, v1, <RET>], last_use=[v6]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v6, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v7
    - stack=[v7, v5, v1, <RET>], last_use=[v7]
      ptr_to_int [v7] -> v8
    - stack=[v8, v5, v1, <RET>], last_use=[v8]
      mload [v8] -> v9
    - stack=[v9, v5, v1, <RET>], last_use=[v5]
      pre: [SWAP1]
      is_zero [v5] -> v35
    - stack=[v35, v9, v1, <RET>], last_use=[v35]
      zext [v35] -> v36
    - stack=[v36, v9, v1, <RET>], last_use=[v36]
      pre: [PUSH(I256 { is_negative: false, abs: 1 })]
      eq [I256 { is_negative: false, abs: 1 }, v36] -> v12
    - stack=[v12, v9, v1, <RET>]
      br [v12] -> [block1, block2]
  block1 P=[] T=[v9, v1]
    inherited from block0: [v9, v1, <RET>]
    - stack=[v9, v1, <RET>]
      pre: [DUP2]
      evm_sload [v1] -> v13
    - stack=[v13, v9, v1, <RET>], last_use=[v13]
      pre: [DUP2]
      add [v9, v13] -> v14
    - stack=[v14, v9, v1, <RET>], last_use=[v14]
      pre: [DUP3]
      evm_sstore [v1, v14]
    - stack=[v9, v1, <RET>]
      pre: [DUP2, PUSH(I256 { is_negative: false, abs: 2 })]
      add [I256 { is_negative: false, abs: 2 }, v1] -> v15
    - stack=[v15, v9, v1, <RET>], last_use=[v15]
      evm_sload [v15] -> v16
    - stack=[v16, v9, v1, <RET>], last_use=[v9, v16]
      add [v16, v9] -> v17
    - stack=[v17, v1, <RET>]
      pre: [DUP2, PUSH(I256 { is_negative: false, abs: 2 })]
      add [I256 { is_negative: false, abs: 2 }, v1] -> v18
    - stack=[v18, v17, v1, <RET>], last_use=[v17, v18]
      evm_sstore [v18, v17]
    - stack=[v1, <RET>], last_use=[v1]
      evm_sload [v1] -> v19
    - stack=[v19, <RET>]
      return [v19]
  block2 P=[] T=[v9, v1]
    inherited from block0: [v9, v1, <RET>]
    - stack=[v9, v1, <RET>]
      pre: [DUP2, PUSH(I256 { is_negative: false, abs: 1 })]
      add [I256 { is_negative: false, abs: 1 }, v1] -> v20
    - stack=[v20, v9, v1, <RET>], last_use=[v20]
      evm_sload [v20] -> v21
    - stack=[v21, v9, v1, <RET>], last_use=[v21]
      pre: [DUP2]
      add [v9, v21] -> v22
    - stack=[v22, v9, v1, <RET>]
      pre: [DUP3, PUSH(I256 { is_negative: false, abs: 1 })]
      add [I256 { is_negative: false, abs: 1 }, v1] -> v23
    - stack=[v23, v22, v9, v1, <RET>], last_use=[v22, v23]
      evm_sstore [v23, v22]
    - stack=[v9, v1, <RET>]
      pre: [DUP2, PUSH(I256 { is_negative: false, abs: 2 })]
      add [I256 { is_negative: false, abs: 2 }, v1] -> v24
    - stack=[v24, v9, v1, <RET>], last_use=[v24]
      evm_sload [v24] -> v25
    - stack=[v25, v9, v1, <RET>], last_use=[v9, v25]
      add [v25, v9] -> v26
    - stack=[v26, v1, <RET>]
      pre: [DUP2, PUSH(I256 { is_negative: false, abs: 2 })]
      add [I256 { is_negative: false, abs: 2 }, v1] -> v27
    - stack=[v27, v26, v1, <RET>], last_use=[v26, v27]
      evm_sstore [v27, v26]
    - stack=[v1, <RET>], last_use=[v1]
      pre: [PUSH(I256 { is_negative: false, abs: 1 })]
      add [I256 { is_negative: false, abs: 1 }, v1] -> v28
    - stack=[v28, <RET>], last_use=[v28]
      evm_sload [v28] -> v29
    - stack=[v29, <RET>]
      return [v29]

// func private %__Coin_recv_0_1(v0.i256, v1.i256) -> i256
  block0 P=[v0, v1] T=[]
    - stack=[v0, v1, <RET>]
      pre: [DUP1]
      int_to_ptr [v0] -> v2
    - stack=[v2, v0, v1, <RET>], last_use=[v2]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v2, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v3
    - stack=[v3, v0, v1, <RET>], last_use=[v3]
      ptr_to_int [v3] -> v4
    - stack=[v4, v0, v1, <RET>], last_use=[v4]
      mload [v4] -> v5
    - stack=[v5, v0, v1, <RET>], last_use=[v0]
      pre: [SWAP1]
      int_to_ptr [v0] -> v6
    - stack=[v6, v5, v1, <RET>], last_use=[v6]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v6, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v7
    - stack=[v7, v5, v1, <RET>], last_use=[v7]
      ptr_to_int [v7] -> v8
    - stack=[v8, v5, v1, <RET>], last_use=[v8]
      mload [v8] -> v9
    - stack=[v9, v5, v1, <RET>], last_use=[v5]
      pre: [SWAP1]
      is_zero [v5] -> v38
    - stack=[v38, v9, v1, <RET>], last_use=[v38]
      zext [v38] -> v39
    - stack=[v39, v9, v1, <RET>], last_use=[v39]
      pre: [PUSH(I256 { is_negative: false, abs: 1 })]
      eq [I256 { is_negative: false, abs: 1 }, v39] -> v12
    - stack=[v12, v9, v1, <RET>]
      br [v12] -> [block1, block2]
  block1 P=[] T=[v9, v1]
    inherited from block0: [v9, v1, <RET>]
    - stack=[v9, v1, <RET>]
      pre: [DUP2]
      evm_sload [v1] -> v13
    - stack=[v13, v9, v1, <RET>], last_use=[v13]
      pre: [DUP2, SWAP1]
      lt [v13, v9] -> v41
    - stack=[v41, v9, v1, <RET>], last_use=[v41]
      zext [v41] -> v42
    - stack=[v42, v9, v1, <RET>], last_use=[v42]
      is_zero [v42] -> v43
    - stack=[v43, v9, v1, <RET>], last_use=[v43]
      is_zero [v43] -> v16
    - stack=[v16, v9, v1, <RET>]
      br [v16] -> [block3, block4]
  block3 P=[] T=[]
    inherited from block1: [v9x, v1x, <RET>]
    - stack=[v9x, v1x, <RET>]
      cleanup: [POP, POP]
      return: [PUSH(I256 { is_negative: false, abs: 1 })]
      return [I256 { is_negative: false, abs: 1 }]
  block4 P=[] T=[v9, v1]
    inherited from block1: [v9, v1, <RET>]
    - stack=[v9, v1, <RET>]
      pre: [DUP2]
      evm_sload [v1] -> v22
    - stack=[v22, v9, v1, <RET>], last_use=[v22]
      pre: [DUP2, SWAP1]
      sub [v22, v9] -> v23
    - stack=[v23, v9, v1, <RET>], last_use=[v23]
      pre: [DUP3]
      evm_sstore [v1, v23]
    - stack=[v9, v1, <RET>]
      pre: [DUP2, PUSH(I256 { is_negative: false, abs: 1 })]
      add [I256 { is_negative: false, abs: 1 }, v1] -> v24
    - stack=[v24, v9, v1, <RET>], last_use=[v24]
      evm_sload [v24] -> v25
    - stack=[v25, v9, v1, <RET>], last_use=[v9, v25]
      add [v25, v9] -> v26
    - stack=[v26, v1, <RET>], last_use=[v1]
      pre: [SWAP1, PUSH(I256 { is_negative: false, abs: 1 })]
      add [I256 { is_negative: false, abs: 1 }, v1] -> v27
    - stack=[v27, v26, <RET>], last_use=[v26, v27]
      evm_sstore [v27, v26]
    - stack=[<RET>]
      return: [PUSH(I256 { is_negative: false, abs: 0 })]
      return [I256 { is_negative: false, abs: 0 }]
  block2 P=[] T=[v9, v1]
    inherited from block0: [v9, v1, <RET>]
    - stack=[v9, v1, <RET>]
      pre: [DUP2, PUSH(I256 { is_negative: false, abs: 1 })]
      add [I256 { is_negative: false, abs: 1 }, v1] -> v17
    - stack=[v17, v9, v1, <RET>], last_use=[v17]
      evm_sload [v17] -> v18
    - stack=[v18, v9, v1, <RET>], last_use=[v18]
      pre: [DUP2, SWAP1]
      lt [v18, v9] -> v45
    - stack=[v45, v9, v1, <RET>], last_use=[v45]
      zext [v45] -> v46
    - stack=[v46, v9, v1, <RET>], last_use=[v46]
      is_zero [v46] -> v47
    - stack=[v47, v9, v1, <RET>], last_use=[v47]
      is_zero [v47] -> v21
    - stack=[v21, v9, v1, <RET>]
      br [v21] -> [block5, block6]
  block5 P=[] T=[]
    inherited from block2: [v9x, v1x, <RET>]
    - stack=[v9x, v1x, <RET>]
      cleanup: [POP, POP]
      return: [PUSH(I256 { is_negative: false, abs: 1 })]
      return [I256 { is_negative: false, abs: 1 }]
  block6 P=[] T=[v9, v1]
    inherited from block2: [v9, v1, <RET>]
    - stack=[v9, v1, <RET>]
      pre: [DUP2, PUSH(I256 { is_negative: false, abs: 1 })]
      add [I256 { is_negative: false, abs: 1 }, v1] -> v28
    - stack=[v28, v9, v1, <RET>], last_use=[v28]
      evm_sload [v28] -> v29
    - stack=[v29, v9, v1, <RET>], last_use=[v29]
      pre: [DUP2, SWAP1]
      sub [v29, v9] -> v30
    - stack=[v30, v9, v1, <RET>]
      pre: [DUP3, PUSH(I256 { is_negative: false, abs: 1 })]
      add [I256 { is_negative: false, abs: 1 }, v1] -> v31
    - stack=[v31, v30, v9, v1, <RET>], last_use=[v30, v31]
      evm_sstore [v31, v30]
    - stack=[v9, v1, <RET>]
      pre: [DUP2]
      evm_sload [v1] -> v32
    - stack=[v32, v9, v1, <RET>], last_use=[v9, v32]
      add [v32, v9] -> v33
    - stack=[v33, v1, <RET>], last_use=[v1, v33]
      pre: [SWAP1]
      evm_sstore [v1, v33]
    - stack=[<RET>]
      return: [PUSH(I256 { is_negative: false, abs: 0 })]
      return [I256 { is_negative: false, abs: 0 }]

// func private %__Coin_recv_0_2(v0.i256, v1.i256) -> i256
  block0 P=[v0, v1] T=[]
    - stack=[v0, v1, <RET>], last_use=[v0]
      is_zero [v0] -> v12
    - stack=[v12, v1, <RET>], last_use=[v12]
      zext [v12] -> v13
    - stack=[v13, v1, <RET>], last_use=[v13]
      pre: [PUSH(I256 { is_negative: false, abs: 1 })]
      eq [I256 { is_negative: false, abs: 1 }, v13] -> v4
    - stack=[v4, v1, <RET>]
      br [v4] -> [block1, block2]
  block1 P=[] T=[v1]
    inherited from block0: [v1, <RET>]
    - stack=[v1, <RET>], last_use=[v1]
      evm_sload [v1] -> v5
    - stack=[v5, <RET>]
      return [v5]
  block2 P=[] T=[v1]
    inherited from block0: [v1, <RET>]
    - stack=[v1, <RET>], last_use=[v1]
      pre: [PUSH(I256 { is_negative: false, abs: 1 })]
      add [I256 { is_negative: false, abs: 1 }, v1] -> v6
    - stack=[v6, <RET>], last_use=[v6]
      evm_sload [v6] -> v7
    - stack=[v7, <RET>]
      return [v7]

// func private %__Coin_init()
  block0 P=[] T=[]
    - stack=[]
      sym_addr [] -> v1
    - stack=[v1]
      sym_size [] -> v2
    - stack=[v2, v1]
      evm_code_size [] -> v3
    - stack=[v3, v2, v1]
      pre: [DUP2, DUP4]
      add [v1, v2] -> v39
    - stack=[v39, v3, v2, v1], last_use=[v39]
      pre: [DUP2]
      lt [v3, v39] -> v40
    - stack=[v40, v3, v2, v1], last_use=[v40]
      zext [v40] -> v41
    - stack=[v41, v3, v2, v1], last_use=[v41]
      is_zero [v41] -> v42
    - stack=[v42, v3, v2, v1], last_use=[v42]
      is_zero [v42] -> v8
    - stack=[v8, v3, v2, v1]
      br [v8] -> [block1, block2]
  block1 P=[] T=[]
    inherited from block0: [v3x, v2x, v1x]
    - stack=[v3x, v2x, v1x]
      cleanup: [POP, POP, POP]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 })]
      evm_revert [I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }]
  block2 P=[] T=[v3, v2, v1]
    inherited from block0: [v3, v2, v1]
    - stack=[v3, v2, v1]
      pre: [DUP2, DUP4]
      add [v1, v2] -> v43
    - stack=[v43, v3, v2, v1], last_use=[v43]
      pre: [DUP2]
      sub [v3, v43] -> v13
    - stack=[v13, v3, v2, v1], last_use=[v13]
      evm_malloc [v13] -> v14
    - stack=[v14, v3, v2, v1], last_use=[v14]
      ptr_to_int [v14] -> v15
    - stack=[v15, v3, v2, v1]
      pre: [DUP3, DUP5]
      add [v1, v2] -> v16
    - stack=[v16, v15, v3, v2, v1]
      pre: [DUP4, DUP6]
      add [v1, v2] -> v44
    - stack=[v44, v16, v15, v3, v2, v1], last_use=[v44]
      pre: [DUP4]
      sub [v3, v44] -> v18
    - stack=[v18, v16, v15, v3, v2, v1], last_use=[v16, v18]
      pre: [SWAP1, DUP3]
      evm_code_copy [v15, v16, v18]
    - stack=[v15, v3, v2, v1]
      pre: [PUSH(I256 { is_negative: false, abs: 64 })]
      evm_malloc [I256 { is_negative: false, abs: 64 }] -> v19
    - stack=[v19, v15, v3, v2, v1], last_use=[v19]
      ptr_to_int [v19] -> v20
    - stack=[v20, v15, v3, v2, v1]
      pre: [DUP1]
      int_to_ptr [v20] -> v21
    - stack=[v21, v20, v15, v3, v2, v1], last_use=[v21]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v21, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v22
    - stack=[v22, v20, v15, v3, v2, v1], last_use=[v22]
      ptr_to_int [v22] -> v23
    - stack=[v23, v20, v15, v3, v2, v1], last_use=[v15, v23]
      pre: [SWAP1, SWAP2, SWAP1]
      mstore [v23, v15]
    - stack=[v20, v3, v2, v1]
      pre: [DUP3, DUP5]
      add [v1, v2] -> v45
    - stack=[v45, v20, v3, v2, v1], last_use=[v3, v45]
      pre: [SWAP1, SWAP2]
      sub [v3, v45] -> v25
    - stack=[v25, v20, v2, v1]
      pre: [DUP2]
      int_to_ptr [v20] -> v26
    - stack=[v26, v25, v20, v2, v1], last_use=[v26]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v26, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v27
    - stack=[v27, v25, v20, v2, v1], last_use=[v27]
      ptr_to_int [v27] -> v28
    - stack=[v28, v25, v20, v2, v1], last_use=[v25, v28]
      mstore [v28, v25]
    - stack=[v20, v2, v1], last_use=[v20]
      pre: [PUSH_CONT, SWAP1]
      call [v20] -> v29
    - stack=[v29x, v2, v1]
      cleanup: [POP]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 })]
      evm_sstore [I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }]
    - stack=[v2, v1]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 })]
      evm_sstore [I256 { is_negative: false, abs: 1 }, I256 { is_negative: false, abs: 0 }]
    - stack=[v2, v1]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 2 })]
      evm_sstore [I256 { is_negative: false, abs: 2 }, I256 { is_negative: false, abs: 0 }]
    - stack=[v2, v1], last_use=[v1]
      pre: [DUP1, SWAP2, PUSH(I256 { is_negative: false, abs: 0 })]
      evm_code_copy [I256 { is_negative: false, abs: 0 }, v1, v2]
    - stack=[v2], last_use=[v2]
      pre: [PUSH(I256 { is_negative: false, abs: 0 })]
      evm_return [I256 { is_negative: false, abs: 0 }, v2]

// func private %__Coin_runtime()
  block0 P=[] T=[]
    - stack=[]
      pre: [PUSH_CONT]
      call [] -> v1
    - stack=[v1]
      pre: [PUSH(I256 { is_negative: false, abs: 64 })]
      evm_malloc [I256 { is_negative: false, abs: 64 }] -> v69
    - stack=[v69, v1], last_use=[v69]
      ptr_to_int [v69] -> v70
    - stack=[v70, v1]
      pre: [DUP1]
      int_to_ptr [v70] -> v71
    - stack=[v71, v70, v1], last_use=[v71]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v71, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v72
    - stack=[v72, v70, v1], last_use=[v72]
      ptr_to_int [v72] -> v73
    - stack=[v73, v70, v1], last_use=[v73]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), SWAP1]
      mstore [v73, I256 { is_negative: false, abs: 0 }]
    - stack=[v70, v1]
      pre: [DUP1]
      int_to_ptr [v70] -> v74
    - stack=[v74, v70, v1], last_use=[v74]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v74, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v75
    - stack=[v75, v70, v1], last_use=[v75]
      ptr_to_int [v75] -> v76
    - stack=[v76, v70, v1], last_use=[v76]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), SWAP1]
      mstore [v76, I256 { is_negative: false, abs: 0 }]
    - stack=[v70, v1], last_use=[v70]
      int_to_ptr [v70] -> v77
    - stack=[v77, v1], last_use=[v77]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v77, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v78
    - stack=[v78, v1], last_use=[v78]
      ptr_to_int [v78] -> v79
    - stack=[v79, v1], last_use=[v79]
      mload [v79] -> v80
    - stack=[v80, v1]
      pre: [PUSH(I256 { is_negative: false, abs: 64 })]
      evm_malloc [I256 { is_negative: false, abs: 64 }] -> v81
    - stack=[v81, v80, v1], last_use=[v81]
      ptr_to_int [v81] -> v82
    - stack=[v82, v80, v1]
      pre: [DUP1]
      int_to_ptr [v82] -> v83
    - stack=[v83, v82, v80, v1], last_use=[v83]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v83, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v84
    - stack=[v84, v82, v80, v1], last_use=[v84]
      ptr_to_int [v84] -> v85
    - stack=[v85, v82, v80, v1], last_use=[v80, v85]
      pre: [SWAP1, SWAP2, SWAP1]
      mstore [v85, v80]
    - stack=[v82, v1]
      pre: [DUP1]
      int_to_ptr [v82] -> v86
    - stack=[v86, v82, v1], last_use=[v86]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v86, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v87
    - stack=[v87, v82, v1], last_use=[v87]
      ptr_to_int [v87] -> v88
    - stack=[v88, v82, v1], last_use=[v88]
      pre: [PUSH(I256 { is_negative: false, abs: 4 }), SWAP1]
      mstore [v88, I256 { is_negative: false, abs: 4 }]
    - stack=[v82, v1]
      pre: [PUSH(I256 { is_negative: false, abs: 96 })]
      evm_malloc [I256 { is_negative: false, abs: 96 }] -> v50
    - stack=[v50, v82, v1], last_use=[v50]
      ptr_to_int [v50] -> v51
    - stack=[v51, v82, v1]
      pre: [DUP2]
      int_to_ptr [v82] -> v52
    - stack=[v52, v51, v82, v1], last_use=[v52]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP3]
      gep [v52, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v53
    - stack=[v53, v51, v82, v1], last_use=[v53]
      ptr_to_int [v53] -> v54
    - stack=[v54, v51, v82, v1], last_use=[v54]
      mload [v54] -> v55
    - stack=[v55, v51, v82, v1]
      pre: [DUP2]
      int_to_ptr [v51] -> v56
    - stack=[v56, v55, v51, v82, v1], last_use=[v56]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP4]
      gep [v56, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v57
    - stack=[v57, v55, v51, v82, v1], last_use=[v57]
      ptr_to_int [v57] -> v58
    - stack=[v58, v55, v51, v82, v1], last_use=[v55, v58]
      mstore [v58, v55]
    - stack=[v51, v82, v1], last_use=[v82]
      pre: [SWAP1]
      int_to_ptr [v82] -> v59
    - stack=[v59, v51, v1], last_use=[v59]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v59, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v60
    - stack=[v60, v51, v1], last_use=[v60]
      ptr_to_int [v60] -> v61
    - stack=[v61, v51, v1], last_use=[v61]
      mload [v61] -> v62
    - stack=[v62, v51, v1]
      pre: [DUP2]
      int_to_ptr [v51] -> v63
    - stack=[v63, v62, v51, v1], last_use=[v63]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP3]
      gep [v63, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v64
    - stack=[v64, v62, v51, v1], last_use=[v64]
      ptr_to_int [v64] -> v65
    - stack=[v65, v62, v51, v1], last_use=[v62, v65]
      mstore [v65, v62]
    - stack=[v51, v1]
      pre: [DUP1]
      int_to_ptr [v51] -> v66
    - stack=[v66, v51, v1], last_use=[v66]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v66, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v67
    - stack=[v67, v51, v1], last_use=[v67]
      ptr_to_int [v67] -> v68
    - stack=[v68, v51, v1], last_use=[v68]
      pre: [PUSH(I256 { is_negative: false, abs: 4 }), SWAP1]
      mstore [v68, I256 { is_negative: false, abs: 4 }]
    - stack=[v51, v1]
      pre: [DUP2, PUSH(I256 { is_negative: false, abs: 2877082652 })]
      eq [I256 { is_negative: false, abs: 2877082652 }, v1] -> v3
    - stack=[v3, v51, v1]
      br [v3] -> [block2, block6]
  block2 P=[] T=[v51]
    inherited from block0: [v51, v1x]
    - stack=[v51, v1x]
      cleanup: [SWAP1, POP]
      pre: [DUP1, PUSH_CONT, SWAP1]
      call [v51] -> v24
    - stack=[v24, v51], last_use=[v51]
      pre: [SWAP1, PUSH_CONT, SWAP1]
      call [v51] -> v25
    - stack=[v25, v24]
      pre: [PUSH(I256 { is_negative: false, abs: 64 })]
      evm_malloc [I256 { is_negative: false, abs: 64 }] -> v26
    - stack=[v26, v25, v24], last_use=[v26]
      ptr_to_int [v26] -> v27
    - stack=[v27, v25, v24]
      pre: [DUP1]
      int_to_ptr [v27] -> v28
    - stack=[v28, v27, v25, v24], last_use=[v28]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v28, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v29
    - stack=[v29, v27, v25, v24], last_use=[v29]
      ptr_to_int [v29] -> v30
    - stack=[v30, v27, v25, v24], last_use=[v24, v30]
      pre: [SWAP1, SWAP3, SWAP1]
      mstore [v30, v24]
    - stack=[v25, v27]
      pre: [DUP2]
      int_to_ptr [v27] -> v31
    - stack=[v31, v25, v27], last_use=[v31]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v31, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v32
    - stack=[v32, v25, v27], last_use=[v32]
      ptr_to_int [v32] -> v33
    - stack=[v33, v25, v27], last_use=[v25, v33]
      mstore [v33, v25]
    - stack=[v27], last_use=[v27]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH_CONT, SWAP2]
      call [I256 { is_negative: false, abs: 0 }, v27] -> v5
    - stack=[v5], last_use=[v5]
      pre: [PUSH_CONT, SWAP1]
      call [v5]
    - stack=[]
      unreachable []
  block6 P=[] T=[v51, v1]
    inherited from block0: [v51, v1]
    - stack=[v51, v1]
      pre: [DUP2, PUSH(I256 { is_negative: false, abs: 217554442 })]
      eq [I256 { is_negative: false, abs: 217554442 }, v1] -> v11
    - stack=[v11, v51, v1]
      br [v11] -> [block3, block7]
  block3 P=[] T=[v51]
    inherited from block6: [v51, v1x]
    - stack=[v51, v1x]
      cleanup: [SWAP1, POP]
      pre: [DUP1, PUSH_CONT, SWAP1]
      call [v51] -> v34
    - stack=[v34, v51], last_use=[v51]
      pre: [SWAP1, PUSH_CONT, SWAP1]
      call [v51] -> v35
    - stack=[v35, v34]
      pre: [PUSH(I256 { is_negative: false, abs: 64 })]
      evm_malloc [I256 { is_negative: false, abs: 64 }] -> v36
    - stack=[v36, v35, v34], last_use=[v36]
      ptr_to_int [v36] -> v37
    - stack=[v37, v35, v34]
      pre: [DUP1]
      int_to_ptr [v37] -> v38
    - stack=[v38, v37, v35, v34], last_use=[v38]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v38, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v39
    - stack=[v39, v37, v35, v34], last_use=[v39]
      ptr_to_int [v39] -> v40
    - stack=[v40, v37, v35, v34], last_use=[v34, v40]
      pre: [SWAP1, SWAP3, SWAP1]
      mstore [v40, v34]
    - stack=[v35, v37]
      pre: [DUP2]
      int_to_ptr [v37] -> v41
    - stack=[v41, v35, v37], last_use=[v41]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v41, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v42
    - stack=[v42, v35, v37], last_use=[v42]
      ptr_to_int [v42] -> v43
    - stack=[v43, v35, v37], last_use=[v35, v43]
      mstore [v43, v35]
    - stack=[v37], last_use=[v37]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH_CONT, SWAP2]
      call [I256 { is_negative: false, abs: 0 }, v37] -> v7
    - stack=[v7], last_use=[v7]
      pre: [PUSH_CONT, SWAP1]
      call [v7]
    - stack=[]
      unreachable []
  block7 P=[] T=[v51, v1]
    inherited from block6: [v51, v1]
    - stack=[v51, v1]
      pre: [DUP2, PUSH(I256 { is_negative: false, abs: 1818602213 })]
      eq [I256 { is_negative: false, abs: 1818602213 }, v1] -> v12
    - stack=[v12, v51, v1]
      br [v12] -> [block4, block8]
  block4 P=[] T=[v51]
    inherited from block7: [v51, v1x]
    - stack=[v51, v1x], last_use=[v51]
      cleanup: [SWAP1, POP]
      pre: [PUSH_CONT, SWAP1]
      call [v51] -> v8
    - stack=[v8], last_use=[v8]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH_CONT, SWAP2]
      call [I256 { is_negative: false, abs: 0 }, v8] -> v9
    - stack=[v9], last_use=[v9]
      pre: [PUSH_CONT, SWAP1]
      call [v9]
    - stack=[]
      unreachable []
  block8 P=[] T=[v1]
    inherited from block7: [v51x, v1]
    - stack=[v51x, v1], last_use=[v1]
      cleanup: [POP]
      pre: [PUSH(I256 { is_negative: false, abs: 960555502 })]
      eq [I256 { is_negative: false, abs: 960555502 }, v1] -> v13
    - stack=[v13]
      br [v13] -> [block5, block1]
  block1 P=[] T=[]
    inherited from block8: []
    - stack=[]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 })]
      evm_revert [I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }]
  block5 P=[] T=[]
    inherited from block8: []
    - stack=[]
      pre: [PUSH(I256 { is_negative: false, abs: 2 })]
      evm_sload [I256 { is_negative: false, abs: 2 }] -> v46
    - stack=[v46], last_use=[v46]
      pre: [PUSH_CONT, SWAP1]
      call [v46]
    - stack=[]
      unreachable []

// func private %create2__Evm_hef0af3106e109414_Coin_h690a60df6720eb85__139b6eceaab4e08e(v0.i256, v1.i256) -> i256
  block0 P=[v0, v1] T=[]
    - stack=[v0, v1, <RET>]
      sym_size [] -> v31
    - stack=[v31, v0, v1, <RET>]
      sym_addr [] -> v32
    - stack=[v32, v31, v0, v1, <RET>]
      pre: [DUP2]
      evm_malloc [v31] -> v5
    - stack=[v5, v32, v31, v0, v1, <RET>], last_use=[v5]
      ptr_to_int [v5] -> v6
    - stack=[v6, v32, v31, v0, v1, <RET>], last_use=[v32]
      pre: [DUP1, SWAP2, DUP4, SWAP2]
      evm_code_copy [v6, v32, v31]
    - stack=[v6, v31, v0, v1, <RET>]
      pre: [DUP1, DUP3]
      add [v31, v6] -> v7
    - stack=[v7, v6, v31, v0, v1, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 96 })]
      evm_malloc [I256 { is_negative: false, abs: 96 }] -> v8
    - stack=[v8, v7, v6, v31, v0, v1, <RET>], last_use=[v8]
      ptr_to_int [v8] -> v9
    - stack=[v9, v7, v6, v31, v0, v1, <RET>]
      pre: [DUP1]
      int_to_ptr [v9] -> v10
    - stack=[v10, v9, v7, v6, v31, v0, v1, <RET>], last_use=[v10]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v10, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v11
    - stack=[v11, v9, v7, v6, v31, v0, v1, <RET>], last_use=[v11]
      ptr_to_int [v11] -> v12
    - stack=[v12, v9, v7, v6, v31, v0, v1, <RET>], last_use=[v12]
      pre: [DUP3, SWAP1]
      mstore [v12, v7]
    - stack=[v9, v7, v6, v31, v0, v1, <RET>]
      pre: [DUP1]
      int_to_ptr [v9] -> v13
    - stack=[v13, v9, v7, v6, v31, v0, v1, <RET>], last_use=[v13]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v13, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v14
    - stack=[v14, v9, v7, v6, v31, v0, v1, <RET>], last_use=[v14]
      ptr_to_int [v14] -> v15
    - stack=[v15, v9, v7, v6, v31, v0, v1, <RET>], last_use=[v15]
      pre: [DUP3, SWAP1]
      mstore [v15, v7]
    - stack=[v9, v7, v6, v31, v0, v1, <RET>], last_use=[v9]
      int_to_ptr [v9] -> v17
    - stack=[v17, v7, v6, v31, v0, v1, <RET>], last_use=[v17]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 2 }), SWAP2]
      gep [v17, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 2 }] -> v18
    - stack=[v18, v7, v6, v31, v0, v1, <RET>], last_use=[v18]
      ptr_to_int [v18] -> v19
    - stack=[v19, v7, v6, v31, v0, v1, <RET>], last_use=[v7, v19]
      mstore [v19, v7]
    - stack=[v6, v31, v0, v1, <RET>], last_use=[v0, v1, v6, v31]
      pre: [SWAP1, SWAP2]
      evm_create2 [v0, v6, v31, v1] -> v33
    - stack=[v33, <RET>]
      pre: [DUP1]
      is_zero [v33] -> v35
    - stack=[v35, v33, <RET>], last_use=[v35]
      zext [v35] -> v36
    - stack=[v36, v33, <RET>], last_use=[v36]
      is_zero [v36] -> v37
    - stack=[v37, v33, <RET>], last_use=[v37]
      is_zero [v37] -> v23
    - stack=[v23, v33, <RET>]
      br [v23] -> [block1, block2]
  block1 P=[] T=[]
    inherited from block0: [v33x, <RET>]
    - stack=[v33x, <RET>]
      cleanup: [POP]
      evm_return_data_size [] -> v24
    - stack=[v24, <RET>]
      pre: [DUP1]
      evm_malloc [v24] -> v25
    - stack=[v25, v24, <RET>], last_use=[v25]
      ptr_to_int [v25] -> v26
    - stack=[v26, v24, <RET>]
      pre: [DUP2, PUSH(I256 { is_negative: false, abs: 0 }), DUP3]
      evm_return_data_copy [v26, I256 { is_negative: false, abs: 0 }, v24]
    - stack=[v26, v24, <RET>], last_use=[v24, v26]
      evm_revert [v26, v24]
  block2 P=[] T=[v33]
    inherited from block0: [v33, <RET>]
    - stack=[v33, <RET>]
      return [v33]

// func public %assert(v0.i256)
  block0 P=[v0] T=[]
    - stack=[v0, <RET>], last_use=[v0]
      is_zero [v0] -> v6
    - stack=[v6, <RET>], last_use=[v6]
      zext [v6] -> v7
    - stack=[v7, <RET>], last_use=[v7]
      is_zero [v7] -> v8
    - stack=[v8, <RET>], last_use=[v8]
      is_zero [v8] -> v3
    - stack=[v3, <RET>]
      br [v3] -> [block1, block2]
  block1 P=[] T=[]
    inherited from block0: [<RET>]
    - stack=[<RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 })]
      evm_revert [I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }]
  block2 P=[] T=[]
    inherited from block0: [<RET>]
    - stack=[<RET>]
      return []

// func private %evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__Credit_h1b40c7da4bcceeac__9489dcd0a297a0c(v0.i256, v1.i256, v2.i256, v3.i256) -> i256
  block0 P=[v0, v1, v2, v3] T=[]
    - stack=[v0, v1, v2, v3, <RET>]
      pre: [PUSH(64)]
      mload [64] -> v55
    - stack=[v55, v0, v1, v2, v3, <RET>]
      pre: [PUSH_CONT]
      call [] -> v28
    - stack=[v28, v55, v0, v1, v2, v3, <RET>]
      pre: [DUP1, PUSH(I256 { is_negative: false, abs: 68 }), PUSH_CONT, SWAP2]
      call [I256 { is_negative: false, abs: 68 }, v28]
    - stack=[v28, v55, v0, v1, v2, v3, <RET>]
      pre: [DUP1]
      int_to_ptr [v28] -> v33
    - stack=[v33, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v33]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v33, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v34
    - stack=[v34, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v34]
      ptr_to_int [v34] -> v35
    - stack=[v35, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v35]
      mload [v35] -> v36
    - stack=[v36, v28, v55, v0, v1, v2, v3, <RET>]
      pre: [PUSH(I256 { is_negative: true, abs: 38226094382411871399633673785201458058701482704730525187925789145324379439104 }), DUP2]
      mstore [v36, I256 { is_negative: true, abs: 38226094382411871399633673785201458058701482704730525187925789145324379439104 }]
    - stack=[v36, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v36]
      pre: [PUSH(I256 { is_negative: false, abs: 4 })]
      add [I256 { is_negative: false, abs: 4 }, v36] -> v31
    - stack=[v31, v28, v55, v0, v1, v2, v3, <RET>]
      pre: [DUP2]
      int_to_ptr [v28] -> v37
    - stack=[v37, v31, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v37]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v37, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v38
    - stack=[v38, v31, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v38]
      ptr_to_int [v38] -> v39
    - stack=[v39, v31, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v31, v39]
      mstore [v39, v31]
    - stack=[v28, v55, v0, v1, v2, v3, <RET>]
      pre: [DUP6]
      int_to_ptr [v3] -> v40
    - stack=[v40, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v40]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v40, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v41
    - stack=[v41, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v41]
      ptr_to_int [v41] -> v42
    - stack=[v42, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v42]
      mload [v42] -> v43
    - stack=[v43, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v3]
      pre: [DUP7]
      int_to_ptr [v3] -> v44
    - stack=[v44, v43, v28, v55, v0, v1, v2, v3x, <RET>], last_use=[v44]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v44, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v45
    - stack=[v45, v43, v28, v55, v0, v1, v2, v3x, <RET>], last_use=[v45]
      ptr_to_int [v45] -> v46
    - stack=[v46, v43, v28, v55, v0, v1, v2, v3x, <RET>], last_use=[v46]
      mload [v46] -> v47
    - stack=[v47, v43, v28, v55, v0, v1, v2, v3x, <RET>], last_use=[v43]
      pre: [SWAP1, DUP3, PUSH_CONT, SWAP2]
      call [v28, v43]
    - stack=[v47, v28, v55, v0, v1, v2, v3x, <RET>], last_use=[v47]
      pre: [DUP2, PUSH_CONT, SWAP2]
      call [v28, v47]
    - stack=[v28, v55, v0, v1, v2, v3x, <RET>], last_use=[v28]
      pre: [PUSH_CONT, SWAP1]
      call [v28] -> v32
    - stack=[v32, v55, v0, v1, v2, v3x, <RET>]
      pre: [DUP1]
      int_to_ptr [v32] -> v5
    - stack=[v5, v32, v55, v0, v1, v2, v3x, <RET>], last_use=[v5]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v5, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v6
    - stack=[v6, v32, v55, v0, v1, v2, v3x, <RET>], last_use=[v6]
      ptr_to_int [v6] -> v7
    - stack=[v7, v32, v55, v0, v1, v2, v3x, <RET>], last_use=[v7]
      mload [v7] -> v8
    - stack=[v8, v32, v55, v0, v1, v2, v3x, <RET>], last_use=[v32]
      pre: [SWAP1]
      int_to_ptr [v32] -> v9
    - stack=[v9, v8, v55, v0, v1, v2, v3x, <RET>], last_use=[v9]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v9, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v10
    - stack=[v10, v8, v55, v0, v1, v2, v3x, <RET>], last_use=[v10]
      ptr_to_int [v10] -> v11
    - stack=[v11, v8, v55, v0, v1, v2, v3x, <RET>], last_use=[v11]
      mload [v11] -> v12
    - stack=[v12, v8, v55, v0, v1, v2, v3x, <RET>], last_use=[v0, v1, v2, v8, v12]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP1, SWAP2, SWAP1, SWAP2, SWAP3, DUP8, DUP7, DUP9]
      evm_call [v1, v0, v2, v8, v12, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v13
    - stack=[v13, v55, v0x, v1x, v2x, v3x, <RET>]
      evm_return_data_size [] -> v14
    - stack=[v14, v13, v55, v0x, v1x, v2x, v3x, <RET>]
      pre: [DUP1]
      evm_malloc [v14] -> v15
    - stack=[v15, v14, v13, v55, v0x, v1x, v2x, v3x, <RET>], last_use=[v15]
      ptr_to_int [v15] -> v16
    - stack=[v16, v14, v13, v55, v0x, v1x, v2x, v3x, <RET>]
      pre: [DUP2, PUSH(I256 { is_negative: false, abs: 0 }), DUP3]
      evm_return_data_copy [v16, I256 { is_negative: false, abs: 0 }, v14]
    - stack=[v16, v14, v13, v55, v0x, v1x, v2x, v3x, <RET>], last_use=[v13]
      pre: [SWAP1, SWAP2]
      is_zero [v13] -> v51
    - stack=[v51, v16, v14, v55, v0x, v1x, v2x, v3x, <RET>], last_use=[v51]
      zext [v51] -> v52
    - stack=[v52, v16, v14, v55, v0x, v1x, v2x, v3x, <RET>], last_use=[v52]
      is_zero [v52] -> v53
    - stack=[v53, v16, v14, v55, v0x, v1x, v2x, v3x, <RET>], last_use=[v53]
      is_zero [v53] -> v19
    - stack=[v19, v16, v14, v55, v0x, v1x, v2x, v3x, <RET>]
      br [v19] -> [block1, block2]
  block1 P=[] T=[v16, v14]
    inherited from block0: [v16, v14, v55x, v0x, v1x, v2x, v3x, <RET>]
    - stack=[v16, v14, v55x, v0x, v1x, v2x, v3x, <RET>], last_use=[v14, v16]
      evm_revert [v16, v14]
  block2 P=[] T=[v16, v14, v55]
    inherited from block0: [v16, v14, v55, v0x, v1x, v2x, v3x, <RET>]
    - stack=[v16, v14, v55, v0x, v1x, v2x, v3x, <RET>], last_use=[v14, v16]
      pre: [SWAP1, PUSH_CONT, SWAP2]
      call [v14, v16] -> v20
    - stack=[v20, v55, v0x, v1x, v2x, v3x, <RET>], last_use=[v55]
      pre: [SWAP1, PUSH(64)]
      mstore [64, v55]
    - stack=[v20, v0x, v1x, v2x, v3x, <RET>]
      cleanup: [SWAP4, POP, POP, POP, POP]
      return [v20]

// func private %evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__Transfer_hbe7d801e15d910f6__66cc42efa72ff9b1(v0.i256, v1.i256, v2.i256, v3.i256) -> i256
  block0 P=[v0, v1, v2, v3] T=[]
    - stack=[v0, v1, v2, v3, <RET>]
      pre: [PUSH(64)]
      mload [64] -> v55
    - stack=[v55, v0, v1, v2, v3, <RET>]
      pre: [PUSH_CONT]
      call [] -> v28
    - stack=[v28, v55, v0, v1, v2, v3, <RET>]
      pre: [DUP1, PUSH(I256 { is_negative: false, abs: 68 }), PUSH_CONT, SWAP2]
      call [I256 { is_negative: false, abs: 68 }, v28]
    - stack=[v28, v55, v0, v1, v2, v3, <RET>]
      pre: [DUP1]
      int_to_ptr [v28] -> v33
    - stack=[v33, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v33]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v33, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v34
    - stack=[v34, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v34]
      ptr_to_int [v34] -> v35
    - stack=[v35, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v35]
      mload [v35] -> v36
    - stack=[v36, v28, v55, v0, v1, v2, v3, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 5865256153521717170471777043062137194249213065319226468487051471953667817472 }), DUP2]
      mstore [v36, I256 { is_negative: false, abs: 5865256153521717170471777043062137194249213065319226468487051471953667817472 }]
    - stack=[v36, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v36]
      pre: [PUSH(I256 { is_negative: false, abs: 4 })]
      add [I256 { is_negative: false, abs: 4 }, v36] -> v31
    - stack=[v31, v28, v55, v0, v1, v2, v3, <RET>]
      pre: [DUP2]
      int_to_ptr [v28] -> v37
    - stack=[v37, v31, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v37]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v37, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v38
    - stack=[v38, v31, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v38]
      ptr_to_int [v38] -> v39
    - stack=[v39, v31, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v31, v39]
      mstore [v39, v31]
    - stack=[v28, v55, v0, v1, v2, v3, <RET>]
      pre: [DUP6]
      int_to_ptr [v3] -> v40
    - stack=[v40, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v40]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v40, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v41
    - stack=[v41, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v41]
      ptr_to_int [v41] -> v42
    - stack=[v42, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v42]
      mload [v42] -> v43
    - stack=[v43, v28, v55, v0, v1, v2, v3, <RET>], last_use=[v3]
      pre: [DUP7]
      int_to_ptr [v3] -> v44
    - stack=[v44, v43, v28, v55, v0, v1, v2, v3x, <RET>], last_use=[v44]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v44, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v45
    - stack=[v45, v43, v28, v55, v0, v1, v2, v3x, <RET>], last_use=[v45]
      ptr_to_int [v45] -> v46
    - stack=[v46, v43, v28, v55, v0, v1, v2, v3x, <RET>], last_use=[v46]
      mload [v46] -> v47
    - stack=[v47, v43, v28, v55, v0, v1, v2, v3x, <RET>], last_use=[v43]
      pre: [SWAP1, DUP3, PUSH_CONT, SWAP2]
      call [v28, v43]
    - stack=[v47, v28, v55, v0, v1, v2, v3x, <RET>], last_use=[v47]
      pre: [DUP2, PUSH_CONT, SWAP2]
      call [v28, v47]
    - stack=[v28, v55, v0, v1, v2, v3x, <RET>], last_use=[v28]
      pre: [PUSH_CONT, SWAP1]
      call [v28] -> v32
    - stack=[v32, v55, v0, v1, v2, v3x, <RET>]
      pre: [DUP1]
      int_to_ptr [v32] -> v5
    - stack=[v5, v32, v55, v0, v1, v2, v3x, <RET>], last_use=[v5]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v5, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v6
    - stack=[v6, v32, v55, v0, v1, v2, v3x, <RET>], last_use=[v6]
      ptr_to_int [v6] -> v7
    - stack=[v7, v32, v55, v0, v1, v2, v3x, <RET>], last_use=[v7]
      mload [v7] -> v8
    - stack=[v8, v32, v55, v0, v1, v2, v3x, <RET>], last_use=[v32]
      pre: [SWAP1]
      int_to_ptr [v32] -> v9
    - stack=[v9, v8, v55, v0, v1, v2, v3x, <RET>], last_use=[v9]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v9, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v10
    - stack=[v10, v8, v55, v0, v1, v2, v3x, <RET>], last_use=[v10]
      ptr_to_int [v10] -> v11
    - stack=[v11, v8, v55, v0, v1, v2, v3x, <RET>], last_use=[v11]
      mload [v11] -> v12
    - stack=[v12, v8, v55, v0, v1, v2, v3x, <RET>], last_use=[v0, v1, v2, v8, v12]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP1, SWAP2, SWAP1, SWAP2, SWAP3, DUP8, DUP7, DUP9]
      evm_call [v1, v0, v2, v8, v12, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v13
    - stack=[v13, v55, v0x, v1x, v2x, v3x, <RET>]
      evm_return_data_size [] -> v14
    - stack=[v14, v13, v55, v0x, v1x, v2x, v3x, <RET>]
      pre: [DUP1]
      evm_malloc [v14] -> v15
    - stack=[v15, v14, v13, v55, v0x, v1x, v2x, v3x, <RET>], last_use=[v15]
      ptr_to_int [v15] -> v16
    - stack=[v16, v14, v13, v55, v0x, v1x, v2x, v3x, <RET>]
      pre: [DUP2, PUSH(I256 { is_negative: false, abs: 0 }), DUP3]
      evm_return_data_copy [v16, I256 { is_negative: false, abs: 0 }, v14]
    - stack=[v16, v14, v13, v55, v0x, v1x, v2x, v3x, <RET>], last_use=[v13]
      pre: [SWAP1, SWAP2]
      is_zero [v13] -> v51
    - stack=[v51, v16, v14, v55, v0x, v1x, v2x, v3x, <RET>], last_use=[v51]
      zext [v51] -> v52
    - stack=[v52, v16, v14, v55, v0x, v1x, v2x, v3x, <RET>], last_use=[v52]
      is_zero [v52] -> v53
    - stack=[v53, v16, v14, v55, v0x, v1x, v2x, v3x, <RET>], last_use=[v53]
      is_zero [v53] -> v19
    - stack=[v19, v16, v14, v55, v0x, v1x, v2x, v3x, <RET>]
      br [v19] -> [block1, block2]
  block1 P=[] T=[v16, v14]
    inherited from block0: [v16, v14, v55x, v0x, v1x, v2x, v3x, <RET>]
    - stack=[v16, v14, v55x, v0x, v1x, v2x, v3x, <RET>], last_use=[v14, v16]
      evm_revert [v16, v14]
  block2 P=[] T=[v16, v14, v55]
    inherited from block0: [v16, v14, v55, v0x, v1x, v2x, v3x, <RET>]
    - stack=[v16, v14, v55, v0x, v1x, v2x, v3x, <RET>], last_use=[v14, v16]
      pre: [SWAP1, PUSH_CONT, SWAP2]
      call [v14, v16] -> v20
    - stack=[v20, v55, v0x, v1x, v2x, v3x, <RET>], last_use=[v55]
      pre: [SWAP1, PUSH(64)]
      mstore [64, v55]
    - stack=[v20, v0x, v1x, v2x, v3x, <RET>]
      cleanup: [SWAP4, POP, POP, POP, POP]
      return [v20]

// func private %evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__BalanceOf_h891837b06b5610d4__9cd8cdf578aad9be(v0.i256, v1.i256, v2.i256, v3.i256) -> i256
  block0 P=[v0, v1, v2, v3] T=[]
    - stack=[v0, v1, v2, v3, <RET>]
      pre: [PUSH(64)]
      mload [64] -> v47
    - stack=[v47, v0, v1, v2, v3, <RET>]
      pre: [PUSH_CONT]
      call [] -> v28
    - stack=[v28, v47, v0, v1, v2, v3, <RET>]
      pre: [DUP1, PUSH(I256 { is_negative: false, abs: 36 }), PUSH_CONT, SWAP2]
      call [I256 { is_negative: false, abs: 36 }, v28]
    - stack=[v28, v47, v0, v1, v2, v3, <RET>]
      pre: [DUP1]
      int_to_ptr [v28] -> v33
    - stack=[v33, v28, v47, v0, v1, v2, v3, <RET>], last_use=[v33]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v33, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v34
    - stack=[v34, v28, v47, v0, v1, v2, v3, <RET>], last_use=[v34]
      ptr_to_int [v34] -> v35
    - stack=[v35, v28, v47, v0, v1, v2, v3, <RET>], last_use=[v35]
      mload [v35] -> v36
    - stack=[v36, v28, v47, v0, v1, v2, v3, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 49029418671242127934947299235358287917519191605832892196421926281513699115008 }), DUP2]
      mstore [v36, I256 { is_negative: false, abs: 49029418671242127934947299235358287917519191605832892196421926281513699115008 }]
    - stack=[v36, v28, v47, v0, v1, v2, v3, <RET>], last_use=[v36]
      pre: [PUSH(I256 { is_negative: false, abs: 4 })]
      add [I256 { is_negative: false, abs: 4 }, v36] -> v31
    - stack=[v31, v28, v47, v0, v1, v2, v3, <RET>]
      pre: [DUP2]
      int_to_ptr [v28] -> v37
    - stack=[v37, v31, v28, v47, v0, v1, v2, v3, <RET>], last_use=[v37]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v37, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v38
    - stack=[v38, v31, v28, v47, v0, v1, v2, v3, <RET>], last_use=[v38]
      ptr_to_int [v38] -> v39
    - stack=[v39, v31, v28, v47, v0, v1, v2, v3, <RET>], last_use=[v31, v39]
      mstore [v39, v31]
    - stack=[v28, v47, v0, v1, v2, v3, <RET>], last_use=[v3]
      pre: [SWAP5, DUP6, PUSH_CONT, SWAP2]
      call [v28, v3]
    - stack=[v47, v0, v1, v2, v28, <RET>], last_use=[v28]
      pre: [SWAP1, SWAP2, SWAP3, SWAP4, PUSH_CONT, SWAP1]
      call [v28] -> v32
    - stack=[v32, v47, v0, v1, v2, <RET>]
      pre: [DUP1]
      int_to_ptr [v32] -> v5
    - stack=[v5, v32, v47, v0, v1, v2, <RET>], last_use=[v5]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v5, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v6
    - stack=[v6, v32, v47, v0, v1, v2, <RET>], last_use=[v6]
      ptr_to_int [v6] -> v7
    - stack=[v7, v32, v47, v0, v1, v2, <RET>], last_use=[v7]
      mload [v7] -> v8
    - stack=[v8, v32, v47, v0, v1, v2, <RET>], last_use=[v32]
      pre: [SWAP1]
      int_to_ptr [v32] -> v9
    - stack=[v9, v8, v47, v0, v1, v2, <RET>], last_use=[v9]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v9, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v10
    - stack=[v10, v8, v47, v0, v1, v2, <RET>], last_use=[v10]
      ptr_to_int [v10] -> v11
    - stack=[v11, v8, v47, v0, v1, v2, <RET>], last_use=[v11]
      mload [v11] -> v12
    - stack=[v12, v8, v47, v0, v1, v2, <RET>], last_use=[v0, v1, v2, v8, v12]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP1, SWAP2, SWAP1, SWAP2, SWAP3, DUP8, DUP7, DUP9]
      evm_call [v1, v0, v2, v8, v12, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v13
    - stack=[v13, v47, v0x, v1x, v2x, <RET>]
      evm_return_data_size [] -> v14
    - stack=[v14, v13, v47, v0x, v1x, v2x, <RET>]
      pre: [DUP1]
      evm_malloc [v14] -> v15
    - stack=[v15, v14, v13, v47, v0x, v1x, v2x, <RET>], last_use=[v15]
      ptr_to_int [v15] -> v16
    - stack=[v16, v14, v13, v47, v0x, v1x, v2x, <RET>]
      pre: [DUP2, PUSH(I256 { is_negative: false, abs: 0 }), DUP3]
      evm_return_data_copy [v16, I256 { is_negative: false, abs: 0 }, v14]
    - stack=[v16, v14, v13, v47, v0x, v1x, v2x, <RET>], last_use=[v13]
      pre: [SWAP1, SWAP2]
      is_zero [v13] -> v43
    - stack=[v43, v16, v14, v47, v0x, v1x, v2x, <RET>], last_use=[v43]
      zext [v43] -> v44
    - stack=[v44, v16, v14, v47, v0x, v1x, v2x, <RET>], last_use=[v44]
      is_zero [v44] -> v45
    - stack=[v45, v16, v14, v47, v0x, v1x, v2x, <RET>], last_use=[v45]
      is_zero [v45] -> v19
    - stack=[v19, v16, v14, v47, v0x, v1x, v2x, <RET>]
      br [v19] -> [block1, block2]
  block1 P=[] T=[v16, v14]
    inherited from block0: [v16, v14, v47x, v0x, v1x, v2x, <RET>]
    - stack=[v16, v14, v47x, v0x, v1x, v2x, <RET>], last_use=[v14, v16]
      evm_revert [v16, v14]
  block2 P=[] T=[v16, v14, v47]
    inherited from block0: [v16, v14, v47, v0x, v1x, v2x, <RET>]
    - stack=[v16, v14, v47, v0x, v1x, v2x, <RET>], last_use=[v14, v16]
      pre: [SWAP1, PUSH_CONT, SWAP2]
      call [v14, v16] -> v20
    - stack=[v20, v47, v0x, v1x, v2x, <RET>], last_use=[v47]
      pre: [SWAP1, PUSH(64)]
      mstore [64, v47]
    - stack=[v20, v0x, v1x, v2x, <RET>]
      cleanup: [SWAP3, POP, POP, POP]
      return [v20]

// func private %evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__TotalSupply_h7bb395110a25abc2__8d4065b5d6bedb33(v0.i256, v1.i256, v2.i256) -> i256
  block0 P=[v0, v1, v2] T=[]
    - stack=[v0, v1, v2, <RET>]
      pre: [PUSH(64)]
      mload [64] -> v44
    - stack=[v44, v0, v1, v2, <RET>]
      pre: [PUSH_CONT]
      call [] -> v26
    - stack=[v26, v44, v0, v1, v2, <RET>]
      pre: [DUP1, PUSH(I256 { is_negative: false, abs: 4 }), PUSH_CONT, SWAP2]
      call [I256 { is_negative: false, abs: 4 }, v26]
    - stack=[v26, v44, v0, v1, v2, <RET>]
      pre: [DUP1]
      int_to_ptr [v26] -> v31
    - stack=[v31, v26, v44, v0, v1, v2, <RET>], last_use=[v31]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v31, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v32
    - stack=[v32, v26, v44, v0, v1, v2, <RET>], last_use=[v32]
      ptr_to_int [v32] -> v33
    - stack=[v33, v26, v44, v0, v1, v2, <RET>], last_use=[v33]
      mload [v33] -> v34
    - stack=[v34, v26, v44, v0, v1, v2, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 25896525104758109717587551599753715025570125426639959714953863856948019986432 }), DUP2]
      mstore [v34, I256 { is_negative: false, abs: 25896525104758109717587551599753715025570125426639959714953863856948019986432 }]
    - stack=[v34, v26, v44, v0, v1, v2, <RET>], last_use=[v34]
      pre: [PUSH(I256 { is_negative: false, abs: 4 })]
      add [I256 { is_negative: false, abs: 4 }, v34] -> v29
    - stack=[v29, v26, v44, v0, v1, v2, <RET>]
      pre: [DUP2]
      int_to_ptr [v26] -> v35
    - stack=[v35, v29, v26, v44, v0, v1, v2, <RET>], last_use=[v35]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v35, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v36
    - stack=[v36, v29, v26, v44, v0, v1, v2, <RET>], last_use=[v36]
      ptr_to_int [v36] -> v37
    - stack=[v37, v29, v26, v44, v0, v1, v2, <RET>], last_use=[v29, v37]
      mstore [v37, v29]
    - stack=[v26, v44, v0, v1, v2, <RET>], last_use=[v26]
      pre: [PUSH_CONT, SWAP1]
      call [v26] -> v30
    - stack=[v30, v44, v0, v1, v2, <RET>]
      pre: [DUP1]
      int_to_ptr [v30] -> v4
    - stack=[v4, v30, v44, v0, v1, v2, <RET>], last_use=[v4]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v4, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v5
    - stack=[v5, v30, v44, v0, v1, v2, <RET>], last_use=[v5]
      ptr_to_int [v5] -> v6
    - stack=[v6, v30, v44, v0, v1, v2, <RET>], last_use=[v6]
      mload [v6] -> v7
    - stack=[v7, v30, v44, v0, v1, v2, <RET>], last_use=[v30]
      pre: [SWAP1]
      int_to_ptr [v30] -> v8
    - stack=[v8, v7, v44, v0, v1, v2, <RET>], last_use=[v8]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v8, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v9
    - stack=[v9, v7, v44, v0, v1, v2, <RET>], last_use=[v9]
      ptr_to_int [v9] -> v10
    - stack=[v10, v7, v44, v0, v1, v2, <RET>], last_use=[v10]
      mload [v10] -> v11
    - stack=[v11, v7, v44, v0, v1, v2, <RET>], last_use=[v0, v1, v2, v7, v11]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP1, SWAP2, SWAP1, SWAP2, SWAP3, DUP8, DUP7, DUP9]
      evm_call [v1, v0, v2, v7, v11, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v12
    - stack=[v12, v44, v0x, v1x, v2x, <RET>]
      evm_return_data_size [] -> v13
    - stack=[v13, v12, v44, v0x, v1x, v2x, <RET>]
      pre: [DUP1]
      evm_malloc [v13] -> v14
    - stack=[v14, v13, v12, v44, v0x, v1x, v2x, <RET>], last_use=[v14]
      ptr_to_int [v14] -> v15
    - stack=[v15, v13, v12, v44, v0x, v1x, v2x, <RET>]
      pre: [DUP2, PUSH(I256 { is_negative: false, abs: 0 }), DUP3]
      evm_return_data_copy [v15, I256 { is_negative: false, abs: 0 }, v13]
    - stack=[v15, v13, v12, v44, v0x, v1x, v2x, <RET>], last_use=[v12]
      pre: [SWAP1, SWAP2]
      is_zero [v12] -> v40
    - stack=[v40, v15, v13, v44, v0x, v1x, v2x, <RET>], last_use=[v40]
      zext [v40] -> v41
    - stack=[v41, v15, v13, v44, v0x, v1x, v2x, <RET>], last_use=[v41]
      is_zero [v41] -> v42
    - stack=[v42, v15, v13, v44, v0x, v1x, v2x, <RET>], last_use=[v42]
      is_zero [v42] -> v18
    - stack=[v18, v15, v13, v44, v0x, v1x, v2x, <RET>]
      br [v18] -> [block1, block2]
  block1 P=[] T=[v15, v13]
    inherited from block0: [v15, v13, v44x, v0x, v1x, v2x, <RET>]
    - stack=[v15, v13, v44x, v0x, v1x, v2x, <RET>], last_use=[v13, v15]
      evm_revert [v15, v13]
  block2 P=[] T=[v15, v13, v44]
    inherited from block0: [v15, v13, v44, v0x, v1x, v2x, <RET>]
    - stack=[v15, v13, v44, v0x, v1x, v2x, <RET>], last_use=[v13, v15]
      pre: [SWAP1, PUSH_CONT, SWAP2]
      call [v13, v15] -> v19
    - stack=[v19, v44, v0x, v1x, v2x, <RET>], last_use=[v44]
      pre: [SWAP1, PUSH(64)]
      mstore [64, v44]
    - stack=[v19, v0x, v1x, v2x, <RET>]
      cleanup: [SWAP3, POP, POP, POP]
      return [v19]

// func public %alloc(v0.i256) -> i256
  block0 P=[v0] T=[]
    - stack=[v0, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 64 })]
      mload [I256 { is_negative: false, abs: 64 }] -> v1
    - stack=[v1, v0, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 128 })]
      mload [I256 { is_negative: false, abs: 128 }] -> v2
    - stack=[v2, v1, v0, <RET>]
      pre: [DUP2, DUP2]
      gt [v2, v1] -> v22
    - stack=[v22, v2, v1, v0, <RET>], last_use=[v22]
      zext [v22] -> v23
    - stack=[v23, v2, v1, v0, <RET>], last_use=[v23]
      is_zero [v23] -> v24
    - stack=[v24, v2, v1, v0, <RET>], last_use=[v24]
      is_zero [v24] -> v5
    - stack=[v5, v2, v1, v0, <RET>]
      br [v5] -> [block1, block7]
  block1 P=[] T=[v2, v0]
    inherited from block0: [v2, v1x, v0, <RET>]
    - stack=[v2, v1x, v0, <RET>]
      cleanup: [SWAP1, POP]
      jump -> block2
  block7 P=[] T=[v1, v0]
    inherited from block0: [v2x, v1, v0, <RET>]
    - stack=[v2x, v1, v0, <RET>]
      cleanup: [POP]
      jump -> block2
  block2 P=[v6] T=[v0]
    - stack=[v6, v0, <RET>]
      pre: [DUP1]
      is_zero [v6] -> v26
    - stack=[v26, v6, v0, <RET>], last_use=[v26]
      zext [v26] -> v27
    - stack=[v27, v6, v0, <RET>], last_use=[v27]
      is_zero [v27] -> v28
    - stack=[v28, v6, v0, <RET>], last_use=[v28]
      is_zero [v28] -> v9
    - stack=[v9, v6, v0, <RET>]
      br [v9] -> [block3, block8]
  block3 P=[] T=[v0]
    inherited from block2: [v6x, v0, <RET>]
    - stack=[v6x, v0, <RET>]
      cleanup: [POP]
      evm_msize [] -> v10
    - stack=[v10, v0, <RET>]
      jump -> block4
  block8 P=[] T=[v6, v0]
    inherited from block2: [v6, v0, <RET>]
    - stack=[v6, v0, <RET>]
      jump -> block4
  block4 P=[v11] T=[v0]
    - stack=[v11, v0, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 8192 }), DUP2]
      lt [v11, I256 { is_negative: false, abs: 8192 }] -> v30
    - stack=[v30, v11, v0, <RET>], last_use=[v30]
      zext [v30] -> v31
    - stack=[v31, v11, v0, <RET>], last_use=[v31]
      is_zero [v31] -> v32
    - stack=[v32, v11, v0, <RET>], last_use=[v32]
      is_zero [v32] -> v14
    - stack=[v14, v11, v0, <RET>]
      br [v14] -> [block5, block9]
  block5 P=[] T=[v0]
    inherited from block4: [v11x, v0, <RET>]
    - stack=[v11x, v0, <RET>]
      cleanup: [POP]
      exit(block6): [PUSH(I256 { is_negative: false, abs: 8192 })]
      jump -> block6
  block9 P=[] T=[v11, v0]
    inherited from block4: [v11, v0, <RET>]
    - stack=[v11, v0, <RET>]
      jump -> block6
  block6 P=[v15] T=[v0]
    - stack=[v15, v0, <RET>], last_use=[v0]
      pre: [DUP1, SWAP2]
      add [v0, v15] -> v16
    - stack=[v16, v15, <RET>], last_use=[v16]
      pre: [PUSH(I256 { is_negative: false, abs: 64 })]
      mstore [I256 { is_negative: false, abs: 64 }, v16]
    - stack=[v15, <RET>]
      return [v15]

// func private %runtime_selector__Evm_hef0af3106e109414_Sol_hfd482bb803ad8c5f__e4e3f8d20b3805a2() -> i256
  block0 P=[] T=[]
    - stack=[<RET>]
      evm_calldata_size [] -> v9
    - stack=[v9, <RET>], last_use=[v9]
      pre: [PUSH(I256 { is_negative: false, abs: 4 }), SWAP1]
      lt [v9, I256 { is_negative: false, abs: 4 }] -> v17
    - stack=[v17, <RET>], last_use=[v17]
      zext [v17] -> v18
    - stack=[v18, <RET>], last_use=[v18]
      is_zero [v18] -> v19
    - stack=[v19, <RET>], last_use=[v19]
      is_zero [v19] -> v4
    - stack=[v4, <RET>]
      br [v4] -> [block1, block2]
  block1 P=[] T=[]
    inherited from block0: [<RET>]
    - stack=[<RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 })]
      evm_revert [I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }]
  block2 P=[] T=[]
    inherited from block0: [<RET>]
    - stack=[<RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 0 })]
      evm_calldata_load [I256 { is_negative: false, abs: 0 }] -> v12
    - stack=[v12, <RET>], last_use=[v12]
      pre: [PUSH(I256 { is_negative: false, abs: 224 })]
      shr [I256 { is_negative: false, abs: 224 }, v12] -> v14
    - stack=[v14, <RET>]
      return [v14]

// func private %return_value__Evm_hef0af3106e109414_Sol_hfd482bb803ad8c5f_u256__c4b26908c66ef75f(v0.i256)
  block0 P=[v0] T=[]
    - stack=[v0]
      pre: [PUSH_CONT]
      call [] -> v1
    - stack=[v1, v0]
      pre: [DUP1, PUSH(I256 { is_negative: false, abs: 32 }), PUSH_CONT, SWAP2]
      call [I256 { is_negative: false, abs: 32 }, v1]
    - stack=[v1, v0]
      pre: [DUP1]
      int_to_ptr [v1] -> v19
    - stack=[v19, v1, v0], last_use=[v19]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v19, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v20
    - stack=[v20, v1, v0], last_use=[v20]
      ptr_to_int [v20] -> v21
    - stack=[v21, v1, v0], last_use=[v21]
      mload [v21] -> v22
    - stack=[v22, v1, v0], last_use=[v0]
      pre: [SWAP2, DUP3]
      mstore [v22, v0]
    - stack=[v1, v22], last_use=[v22]
      pre: [SWAP1, PUSH(I256 { is_negative: false, abs: 32 })]
      add [I256 { is_negative: false, abs: 32 }, v22] -> v23
    - stack=[v23, v1]
      pre: [DUP2]
      int_to_ptr [v1] -> v24
    - stack=[v24, v23, v1], last_use=[v24]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v24, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v25
    - stack=[v25, v23, v1], last_use=[v25]
      ptr_to_int [v25] -> v26
    - stack=[v26, v23, v1], last_use=[v23, v26]
      mstore [v26, v23]
    - stack=[v1], last_use=[v1]
      pre: [PUSH_CONT, SWAP1]
      call [v1] -> v3
    - stack=[v3]
      pre: [DUP1]
      int_to_ptr [v3] -> v4
    - stack=[v4, v3], last_use=[v4]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v4, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v5
    - stack=[v5, v3], last_use=[v5]
      ptr_to_int [v5] -> v6
    - stack=[v6, v3], last_use=[v6]
      mload [v6] -> v7
    - stack=[v7, v3], last_use=[v3]
      pre: [SWAP1]
      int_to_ptr [v3] -> v8
    - stack=[v8, v7], last_use=[v8]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v8, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v9
    - stack=[v9, v7], last_use=[v9]
      ptr_to_int [v9] -> v10
    - stack=[v10, v7], last_use=[v10]
      mload [v10] -> v11
    - stack=[v11, v7], last_use=[v7, v11]
      pre: [SWAP1]
      evm_return [v7, v11]

// func private %decode_returndata__u256__3271ca15373d4483(v0.i256, v1.i256) -> i256
  block0 P=[v0, v1] T=[]
    - stack=[v0, v1, <RET>]
      pre: [PUSH(64)]
      mload [64] -> v24
    - stack=[v24, v0, v1, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 32 }), DUP4]
      lt [v1, I256 { is_negative: false, abs: 32 }] -> v20
    - stack=[v20, v24, v0, v1, <RET>], last_use=[v20]
      zext [v20] -> v21
    - stack=[v21, v24, v0, v1, <RET>], last_use=[v21]
      is_zero [v21] -> v22
    - stack=[v22, v24, v0, v1, <RET>], last_use=[v22]
      is_zero [v22] -> v4
    - stack=[v4, v24, v0, v1, <RET>]
      br [v4] -> [block1, block2]
  block1 P=[] T=[]
    inherited from block0: [v24x, v0x, v1x, <RET>]
    - stack=[v24x, v0x, v1x, <RET>]
      cleanup: [POP, POP, POP]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 })]
      evm_revert [I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }]
  block2 P=[] T=[v24, v0, v1]
    inherited from block0: [v24, v0, v1, <RET>]
    - stack=[v24, v0, v1, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 64 })]
      evm_malloc [I256 { is_negative: false, abs: 64 }] -> v5
    - stack=[v5, v24, v0, v1, <RET>], last_use=[v5]
      ptr_to_int [v5] -> v6
    - stack=[v6, v24, v0, v1, <RET>]
      pre: [DUP1]
      int_to_ptr [v6] -> v7
    - stack=[v7, v6, v24, v0, v1, <RET>], last_use=[v7]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v7, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v8
    - stack=[v8, v6, v24, v0, v1, <RET>], last_use=[v8]
      ptr_to_int [v8] -> v9
    - stack=[v9, v6, v24, v0, v1, <RET>], last_use=[v0, v9]
      pre: [SWAP1, SWAP3, SWAP1]
      mstore [v9, v0]
    - stack=[v24, v6, v1, <RET>]
      pre: [DUP2]
      int_to_ptr [v6] -> v10
    - stack=[v10, v24, v6, v1, <RET>], last_use=[v10]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v10, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v11
    - stack=[v11, v24, v6, v1, <RET>], last_use=[v11]
      ptr_to_int [v11] -> v12
    - stack=[v12, v24, v6, v1, <RET>], last_use=[v1, v12]
      pre: [SWAP1, SWAP3, SWAP1]
      mstore [v12, v1]
    - stack=[v6, v24, <RET>], last_use=[v6]
      pre: [PUSH_CONT, SWAP1]
      call [v6] -> v13
    - stack=[v13, v24, <RET>], last_use=[v13]
      pre: [PUSH_CONT, SWAP1]
      call [v13] -> v14
    - stack=[v14, v24, <RET>], last_use=[v24]
      pre: [SWAP1, PUSH(64)]
      mstore [64, v24]
    - stack=[v14, <RET>]
      return [v14]

// func public %soldecoder_i__ha12a03fcb5ba844b_new__MemoryBytes_h1e381015a9b0111b__59e0d528d54cca1b(v0.i256) -> i256
  block0 P=[v0] T=[]
    - stack=[v0, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 96 })]
      evm_malloc [I256 { is_negative: false, abs: 96 }] -> v32
    - stack=[v32, v0, <RET>], last_use=[v32]
      ptr_to_int [v32] -> v33
    - stack=[v33, v0, <RET>]
      pre: [DUP2]
      int_to_ptr [v0] -> v34
    - stack=[v34, v33, v0, <RET>], last_use=[v34]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v34, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v35
    - stack=[v35, v33, v0, <RET>], last_use=[v35]
      ptr_to_int [v35] -> v36
    - stack=[v36, v33, v0, <RET>], last_use=[v36]
      mload [v36] -> v37
    - stack=[v37, v33, v0, <RET>]
      pre: [DUP2]
      int_to_ptr [v33] -> v38
    - stack=[v38, v37, v33, v0, <RET>], last_use=[v38]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP3]
      gep [v38, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v39
    - stack=[v39, v37, v33, v0, <RET>], last_use=[v39]
      ptr_to_int [v39] -> v40
    - stack=[v40, v37, v33, v0, <RET>], last_use=[v37, v40]
      mstore [v40, v37]
    - stack=[v33, v0, <RET>], last_use=[v0]
      pre: [SWAP1]
      int_to_ptr [v0] -> v41
    - stack=[v41, v33, <RET>], last_use=[v41]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v41, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v42
    - stack=[v42, v33, <RET>], last_use=[v42]
      ptr_to_int [v42] -> v43
    - stack=[v43, v33, <RET>], last_use=[v43]
      mload [v43] -> v44
    - stack=[v44, v33, <RET>]
      pre: [DUP2]
      int_to_ptr [v33] -> v45
    - stack=[v45, v44, v33, <RET>], last_use=[v45]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP3]
      gep [v45, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v46
    - stack=[v46, v44, v33, <RET>], last_use=[v46]
      ptr_to_int [v46] -> v47
    - stack=[v47, v44, v33, <RET>], last_use=[v44, v47]
      mstore [v47, v44]
    - stack=[v33, <RET>]
      pre: [DUP1]
      int_to_ptr [v33] -> v48
    - stack=[v48, v33, <RET>], last_use=[v48]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v48, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v49
    - stack=[v49, v33, <RET>], last_use=[v49]
      ptr_to_int [v49] -> v50
    - stack=[v50, v33, <RET>], last_use=[v50]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), SWAP1]
      mstore [v50, I256 { is_negative: false, abs: 0 }]
    - stack=[v33, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 128 })]
      evm_malloc [I256 { is_negative: false, abs: 128 }] -> v2
    - stack=[v2, v33, <RET>], last_use=[v2]
      ptr_to_int [v2] -> v3
    - stack=[v3, v33, <RET>]
      pre: [DUP2]
      int_to_ptr [v33] -> v4
    - stack=[v4, v3, v33, <RET>], last_use=[v4]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP3]
      gep [v4, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v5
    - stack=[v5, v3, v33, <RET>], last_use=[v5]
      ptr_to_int [v5] -> v6
    - stack=[v6, v3, v33, <RET>], last_use=[v6]
      mload [v6] -> v7
    - stack=[v7, v3, v33, <RET>]
      pre: [DUP2]
      int_to_ptr [v3] -> v8
    - stack=[v8, v7, v3, v33, <RET>], last_use=[v8]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP4]
      gep [v8, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v9
    - stack=[v9, v7, v3, v33, <RET>], last_use=[v9]
      ptr_to_int [v9] -> v10
    - stack=[v10, v7, v3, v33, <RET>], last_use=[v7, v10]
      mstore [v10, v7]
    - stack=[v3, v33, <RET>]
      pre: [DUP2]
      int_to_ptr [v33] -> v11
    - stack=[v11, v3, v33, <RET>], last_use=[v11]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP3]
      gep [v11, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v12
    - stack=[v12, v3, v33, <RET>], last_use=[v12]
      ptr_to_int [v12] -> v13
    - stack=[v13, v3, v33, <RET>], last_use=[v13]
      mload [v13] -> v14
    - stack=[v14, v3, v33, <RET>]
      pre: [DUP2]
      int_to_ptr [v3] -> v15
    - stack=[v15, v14, v3, v33, <RET>], last_use=[v15]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP4]
      gep [v15, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v16
    - stack=[v16, v14, v3, v33, <RET>], last_use=[v16]
      ptr_to_int [v16] -> v17
    - stack=[v17, v14, v3, v33, <RET>], last_use=[v14, v17]
      mstore [v17, v14]
    - stack=[v3, v33, <RET>], last_use=[v33]
      pre: [SWAP1]
      int_to_ptr [v33] -> v18
    - stack=[v18, v3, <RET>], last_use=[v18]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v18, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v19
    - stack=[v19, v3, <RET>], last_use=[v19]
      ptr_to_int [v19] -> v20
    - stack=[v20, v3, <RET>], last_use=[v20]
      mload [v20] -> v21
    - stack=[v21, v3, <RET>]
      pre: [DUP2]
      int_to_ptr [v3] -> v22
    - stack=[v22, v21, v3, <RET>], last_use=[v22]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP3]
      gep [v22, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v23
    - stack=[v23, v21, v3, <RET>], last_use=[v23]
      ptr_to_int [v23] -> v24
    - stack=[v24, v21, v3, <RET>], last_use=[v21, v24]
      mstore [v24, v21]
    - stack=[v3, <RET>]
      pre: [DUP1]
      int_to_ptr [v3] -> v25
    - stack=[v25, v3, <RET>], last_use=[v25]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v25, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v26
    - stack=[v26, v3, <RET>], last_use=[v26]
      ptr_to_int [v26] -> v27
    - stack=[v27, v3, <RET>], last_use=[v27]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), SWAP1]
      mstore [v27, I256 { is_negative: false, abs: 0 }]
    - stack=[v3, <RET>]
      return [v3]

// func private %u256_h3271ca15373d4483_encode_hab7243eccf2714fb_encode__Sol_hfd482bb803ad8c5f_SolEncoder_h1b9228b90dad6928__1a070c3866d16383(v0.i256, v1.i256)
  block0 P=[v0, v1] T=[]
    - stack=[v0, v1, <RET>]
      pre: [DUP2]
      int_to_ptr [v1] -> v5
    - stack=[v5, v0, v1, <RET>], last_use=[v5]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v5, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v6
    - stack=[v6, v0, v1, <RET>], last_use=[v6]
      ptr_to_int [v6] -> v7
    - stack=[v7, v0, v1, <RET>], last_use=[v7]
      mload [v7] -> v8
    - stack=[v8, v0, v1, <RET>], last_use=[v0]
      pre: [SWAP1, DUP2]
      mstore [v8, v0]
    - stack=[v8, v1, <RET>], last_use=[v8]
      pre: [PUSH(I256 { is_negative: false, abs: 32 })]
      add [I256 { is_negative: false, abs: 32 }, v8] -> v9
    - stack=[v9, v1, <RET>], last_use=[v1]
      pre: [SWAP1]
      int_to_ptr [v1] -> v10
    - stack=[v10, v9, <RET>], last_use=[v10]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v10, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v11
    - stack=[v11, v9, <RET>], last_use=[v11]
      ptr_to_int [v11] -> v12
    - stack=[v12, v9, <RET>], last_use=[v9, v12]
      mstore [v12, v9]
    - stack=[<RET>]
      return []

// func private %solencoder_h1b9228b90dad6928_abiencoder_hffd58d20d4321024_finish(v0.i256) -> i256
  block0 P=[v0] T=[]
    - stack=[v0, <RET>]
      pre: [DUP1]
      int_to_ptr [v0] -> v1
    - stack=[v1, v0, <RET>], last_use=[v1]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v1, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v2
    - stack=[v2, v0, <RET>], last_use=[v2]
      ptr_to_int [v2] -> v3
    - stack=[v3, v0, <RET>], last_use=[v3]
      mload [v3] -> v4
    - stack=[v4, v0, <RET>], last_use=[v0]
      pre: [SWAP1]
      int_to_ptr [v0] -> v5
    - stack=[v5, v4, <RET>], last_use=[v5]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 2 }), SWAP2]
      gep [v5, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 2 }] -> v6
    - stack=[v6, v4, <RET>], last_use=[v6]
      ptr_to_int [v6] -> v7
    - stack=[v7, v4, <RET>], last_use=[v7]
      mload [v7] -> v8
    - stack=[v8, v4, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 64 })]
      evm_malloc [I256 { is_negative: false, abs: 64 }] -> v9
    - stack=[v9, v8, v4, <RET>], last_use=[v9]
      ptr_to_int [v9] -> v10
    - stack=[v10, v8, v4, <RET>]
      pre: [DUP1]
      int_to_ptr [v10] -> v11
    - stack=[v11, v10, v8, v4, <RET>], last_use=[v11]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v11, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v12
    - stack=[v12, v10, v8, v4, <RET>], last_use=[v12]
      ptr_to_int [v12] -> v13
    - stack=[v13, v10, v8, v4, <RET>], last_use=[v13]
      pre: [DUP4, SWAP1]
      mstore [v13, v4]
    - stack=[v10, v8, v4, <RET>], last_use=[v4, v8]
      pre: [SWAP2, SWAP1]
      sub [v8, v4] -> v14
    - stack=[v14, v10, <RET>]
      pre: [DUP2]
      int_to_ptr [v10] -> v15
    - stack=[v15, v14, v10, <RET>], last_use=[v15]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v15, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v16
    - stack=[v16, v14, v10, <RET>], last_use=[v16]
      ptr_to_int [v16] -> v17
    - stack=[v17, v14, v10, <RET>], last_use=[v14, v17]
      mstore [v17, v14]
    - stack=[v10, <RET>]
      return [v10]

// func public %solencoder_h1b9228b90dad6928_new() -> i256
  block0 P=[] T=[]
    - stack=[<RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 96 })]
      evm_malloc [I256 { is_negative: false, abs: 96 }] -> v0
    - stack=[v0, <RET>], last_use=[v0]
      ptr_to_int [v0] -> v1
    - stack=[v1, <RET>]
      pre: [DUP1]
      int_to_ptr [v1] -> v2
    - stack=[v2, v1, <RET>], last_use=[v2]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v2, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v3
    - stack=[v3, v1, <RET>], last_use=[v3]
      ptr_to_int [v3] -> v4
    - stack=[v4, v1, <RET>], last_use=[v4]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), SWAP1]
      mstore [v4, I256 { is_negative: false, abs: 0 }]
    - stack=[v1, <RET>]
      pre: [DUP1]
      int_to_ptr [v1] -> v5
    - stack=[v5, v1, <RET>], last_use=[v5]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v5, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v6
    - stack=[v6, v1, <RET>], last_use=[v6]
      ptr_to_int [v6] -> v7
    - stack=[v7, v1, <RET>], last_use=[v7]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), SWAP1]
      mstore [v7, I256 { is_negative: false, abs: 0 }]
    - stack=[v1, <RET>]
      pre: [DUP1]
      int_to_ptr [v1] -> v8
    - stack=[v8, v1, <RET>], last_use=[v8]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 2 }), SWAP2]
      gep [v8, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 2 }] -> v9
    - stack=[v9, v1, <RET>], last_use=[v9]
      ptr_to_int [v9] -> v10
    - stack=[v10, v1, <RET>], last_use=[v10]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), SWAP1]
      mstore [v10, I256 { is_negative: false, abs: 0 }]
    - stack=[v1, <RET>]
      return [v1]

// func public %cursor_i__h140a998c67d6d59c_new__MemoryBytes_h1e381015a9b0111b__59e0d528d54cca1b(v0.i256) -> i256
  block0 P=[v0] T=[]
    - stack=[v0, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 96 })]
      evm_malloc [I256 { is_negative: false, abs: 96 }] -> v1
    - stack=[v1, v0, <RET>], last_use=[v1]
      ptr_to_int [v1] -> v2
    - stack=[v2, v0, <RET>]
      pre: [DUP2]
      int_to_ptr [v0] -> v3
    - stack=[v3, v2, v0, <RET>], last_use=[v3]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v3, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v4
    - stack=[v4, v2, v0, <RET>], last_use=[v4]
      ptr_to_int [v4] -> v5
    - stack=[v5, v2, v0, <RET>], last_use=[v5]
      mload [v5] -> v6
    - stack=[v6, v2, v0, <RET>]
      pre: [DUP2]
      int_to_ptr [v2] -> v7
    - stack=[v7, v6, v2, v0, <RET>], last_use=[v7]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP3]
      gep [v7, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v8
    - stack=[v8, v6, v2, v0, <RET>], last_use=[v8]
      ptr_to_int [v8] -> v9
    - stack=[v9, v6, v2, v0, <RET>], last_use=[v6, v9]
      mstore [v9, v6]
    - stack=[v2, v0, <RET>], last_use=[v0]
      pre: [SWAP1]
      int_to_ptr [v0] -> v10
    - stack=[v10, v2, <RET>], last_use=[v10]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v10, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v11
    - stack=[v11, v2, <RET>], last_use=[v11]
      ptr_to_int [v11] -> v12
    - stack=[v12, v2, <RET>], last_use=[v12]
      mload [v12] -> v13
    - stack=[v13, v2, <RET>]
      pre: [DUP2]
      int_to_ptr [v2] -> v14
    - stack=[v14, v13, v2, <RET>], last_use=[v14]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP3]
      gep [v14, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v15
    - stack=[v15, v13, v2, <RET>], last_use=[v15]
      ptr_to_int [v15] -> v16
    - stack=[v16, v13, v2, <RET>], last_use=[v13, v16]
      mstore [v16, v13]
    - stack=[v2, <RET>]
      pre: [DUP1]
      int_to_ptr [v2] -> v17
    - stack=[v17, v2, <RET>], last_use=[v17]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v17, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v18
    - stack=[v18, v2, <RET>], last_use=[v18]
      ptr_to_int [v18] -> v19
    - stack=[v19, v2, <RET>], last_use=[v19]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), SWAP1]
      mstore [v19, I256 { is_negative: false, abs: 0 }]
    - stack=[v2, <RET>]
      return [v2]

// func public %soldecoder_i__ha12a03fcb5ba844b_with_base__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563(v0.i256, v1.i256) -> i256
  block0 P=[v0, v1] T=[]
    - stack=[v0, v1, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 64 })]
      evm_malloc [I256 { is_negative: false, abs: 64 }] -> v27
    - stack=[v27, v0, v1, <RET>], last_use=[v27]
      ptr_to_int [v27] -> v28
    - stack=[v28, v0, v1, <RET>]
      pre: [DUP1]
      int_to_ptr [v28] -> v29
    - stack=[v29, v28, v0, v1, <RET>], last_use=[v29]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v29, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v30
    - stack=[v30, v28, v0, v1, <RET>], last_use=[v30]
      ptr_to_int [v30] -> v31
    - stack=[v31, v28, v0, v1, <RET>], last_use=[v0, v31]
      pre: [SWAP1, SWAP2, SWAP1]
      mstore [v31, v0]
    - stack=[v28, v1, <RET>]
      pre: [DUP1]
      int_to_ptr [v28] -> v32
    - stack=[v32, v28, v1, <RET>], last_use=[v32]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v32, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v33
    - stack=[v33, v28, v1, <RET>], last_use=[v33]
      ptr_to_int [v33] -> v34
    - stack=[v34, v28, v1, <RET>], last_use=[v34]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), SWAP1]
      mstore [v34, I256 { is_negative: false, abs: 0 }]
    - stack=[v28, v1, <RET>], last_use=[v28]
      int_to_ptr [v28] -> v35
    - stack=[v35, v1, <RET>], last_use=[v35]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v35, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v36
    - stack=[v36, v1, <RET>], last_use=[v36]
      ptr_to_int [v36] -> v37
    - stack=[v37, v1, <RET>], last_use=[v37]
      mload [v37] -> v38
    - stack=[v38, v1, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 64 })]
      evm_malloc [I256 { is_negative: false, abs: 64 }] -> v39
    - stack=[v39, v38, v1, <RET>], last_use=[v39]
      ptr_to_int [v39] -> v40
    - stack=[v40, v38, v1, <RET>]
      pre: [DUP1]
      int_to_ptr [v40] -> v41
    - stack=[v41, v40, v38, v1, <RET>], last_use=[v41]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v41, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v42
    - stack=[v42, v40, v38, v1, <RET>], last_use=[v42]
      ptr_to_int [v42] -> v43
    - stack=[v43, v40, v38, v1, <RET>], last_use=[v38, v43]
      pre: [SWAP1, SWAP2, SWAP1]
      mstore [v43, v38]
    - stack=[v40, v1, <RET>]
      pre: [DUP1]
      int_to_ptr [v40] -> v44
    - stack=[v44, v40, v1, <RET>], last_use=[v44]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v44, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v45
    - stack=[v45, v40, v1, <RET>], last_use=[v45]
      ptr_to_int [v45] -> v46
    - stack=[v46, v40, v1, <RET>], last_use=[v46]
      pre: [DUP3, SWAP1]
      mstore [v46, v1]
    - stack=[v40, v1, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 96 })]
      evm_malloc [I256 { is_negative: false, abs: 96 }] -> v4
    - stack=[v4, v40, v1, <RET>], last_use=[v4]
      ptr_to_int [v4] -> v5
    - stack=[v5, v40, v1, <RET>]
      pre: [DUP2]
      int_to_ptr [v40] -> v6
    - stack=[v6, v5, v40, v1, <RET>], last_use=[v6]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP3]
      gep [v6, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v7
    - stack=[v7, v5, v40, v1, <RET>], last_use=[v7]
      ptr_to_int [v7] -> v8
    - stack=[v8, v5, v40, v1, <RET>], last_use=[v8]
      mload [v8] -> v9
    - stack=[v9, v5, v40, v1, <RET>]
      pre: [DUP2]
      int_to_ptr [v5] -> v10
    - stack=[v10, v9, v5, v40, v1, <RET>], last_use=[v10]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP4]
      gep [v10, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v11
    - stack=[v11, v9, v5, v40, v1, <RET>], last_use=[v11]
      ptr_to_int [v11] -> v12
    - stack=[v12, v9, v5, v40, v1, <RET>], last_use=[v9, v12]
      mstore [v12, v9]
    - stack=[v5, v40, v1, <RET>], last_use=[v40]
      pre: [SWAP1]
      int_to_ptr [v40] -> v13
    - stack=[v13, v5, v1, <RET>], last_use=[v13]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v13, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v14
    - stack=[v14, v5, v1, <RET>], last_use=[v14]
      ptr_to_int [v14] -> v15
    - stack=[v15, v5, v1, <RET>], last_use=[v15]
      mload [v15] -> v16
    - stack=[v16, v5, v1, <RET>]
      pre: [DUP2]
      int_to_ptr [v5] -> v17
    - stack=[v17, v16, v5, v1, <RET>], last_use=[v17]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP3]
      gep [v17, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v18
    - stack=[v18, v16, v5, v1, <RET>], last_use=[v18]
      ptr_to_int [v18] -> v19
    - stack=[v19, v16, v5, v1, <RET>], last_use=[v16, v19]
      mstore [v19, v16]
    - stack=[v5, v1, <RET>]
      pre: [DUP1]
      int_to_ptr [v5] -> v20
    - stack=[v20, v5, v1, <RET>], last_use=[v20]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v20, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v21
    - stack=[v21, v5, v1, <RET>], last_use=[v21]
      ptr_to_int [v21] -> v22
    - stack=[v22, v5, v1, <RET>], last_use=[v1, v22]
      pre: [SWAP1, SWAP2, SWAP1]
      mstore [v22, v1]
    - stack=[v5, <RET>]
      return [v5]

// func private %soldecoder_i__ha12a03fcb5ba844b_abidecoder_h638151350e80a086_read_word__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563(v0.i256) -> i256
  block0 P=[v0] T=[]
    - stack=[v0, <RET>]
      pre: [DUP1]
      int_to_ptr [v0] -> v1
    - stack=[v1, v0, <RET>], last_use=[v1]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v1, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v2
    - stack=[v2, v0, <RET>], last_use=[v2]
      ptr_to_int [v2] -> v3
    - stack=[v3, v0, <RET>], last_use=[v3]
      int_to_ptr [v3] -> v4
    - stack=[v4, v0, <RET>], last_use=[v4]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v4, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v5
    - stack=[v5, v0, <RET>], last_use=[v5]
      ptr_to_int [v5] -> v6
    - stack=[v6, v0, <RET>], last_use=[v6]
      mload [v6] -> v7
    - stack=[v7, v0, <RET>]
      evm_calldata_size [] -> v54
    - stack=[v54, v7, v0, <RET>]
      pre: [DUP3]
      int_to_ptr [v0] -> v9
    - stack=[v9, v54, v7, v0, <RET>], last_use=[v9]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v9, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v10
    - stack=[v10, v54, v7, v0, <RET>], last_use=[v10]
      ptr_to_int [v10] -> v11
    - stack=[v11, v54, v7, v0, <RET>], last_use=[v11]
      int_to_ptr [v11] -> v12
    - stack=[v12, v54, v7, v0, <RET>], last_use=[v12]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v12, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v13
    - stack=[v13, v54, v7, v0, <RET>], last_use=[v13]
      ptr_to_int [v13] -> v14
    - stack=[v14, v54, v7, v0, <RET>], last_use=[v14]
      mload [v14] -> v15
    - stack=[v15, v54, v7, v0, <RET>]
      pre: [DUP1, PUSH(I256 { is_negative: false, abs: 32 })]
      add [I256 { is_negative: false, abs: 32 }, v15] -> v16
    - stack=[v16, v15, v54, v7, v0, <RET>]
      pre: [DUP5]
      int_to_ptr [v0] -> v17
    - stack=[v17, v16, v15, v54, v7, v0, <RET>], last_use=[v17]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v17, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v18
    - stack=[v18, v16, v15, v54, v7, v0, <RET>], last_use=[v18]
      ptr_to_int [v18] -> v19
    - stack=[v19, v16, v15, v54, v7, v0, <RET>], last_use=[v19]
      int_to_ptr [v19] -> v20
    - stack=[v20, v16, v15, v54, v7, v0, <RET>], last_use=[v20]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v20, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v21
    - stack=[v21, v16, v15, v54, v7, v0, <RET>], last_use=[v21]
      ptr_to_int [v21] -> v22
    - stack=[v22, v16, v15, v54, v7, v0, <RET>], last_use=[v22]
      mload [v22] -> v23
    - stack=[v23, v16, v15, v54, v7, v0, <RET>], last_use=[v15]
      pre: [SWAP2, PUSH(I256 { is_negative: false, abs: 32 })]
      add [I256 { is_negative: false, abs: 32 }, v15] -> v72
    - stack=[v72, v16, v23, v54, v7, v0, <RET>], last_use=[v7, v54]
      pre: [SWAP4, SWAP1, SWAP3]
      sub [v54, v7] -> v73
    - stack=[v73, v23, v16, v72, v0, <RET>], last_use=[v73]
      pre: [DUP4]
      gt [v72, v73] -> v74
    - stack=[v74, v23, v16, v72, v0, <RET>], last_use=[v74]
      zext [v74] -> v75
    - stack=[v75, v23, v16, v72, v0, <RET>], last_use=[v23, v72]
      pre: [SWAP3]
      lt [v72, v23] -> v76
    - stack=[v76, v16, v75, v0, <RET>], last_use=[v76]
      zext [v76] -> v77
    - stack=[v77, v16, v75, v0, <RET>], last_use=[v75, v77]
      pre: [SWAP1, SWAP2]
      or [v75, v77] -> v78
    - stack=[v78, v16, v0, <RET>], last_use=[v78]
      pre: [PUSH(I256 { is_negative: false, abs: 0 })]
      ne [I256 { is_negative: false, abs: 0 }, v78] -> v29
    - stack=[v29, v16, v0, <RET>]
      br [v29] -> [block1, block2]
  block1 P=[] T=[]
    inherited from block0: [v16x, v0x, <RET>]
    - stack=[v16x, v0x, <RET>]
      cleanup: [POP, POP]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 })]
      evm_revert [I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }]
  block2 P=[] T=[v16, v0]
    inherited from block0: [v16, v0, <RET>]
    - stack=[v16, v0, <RET>]
      pre: [DUP2]
      int_to_ptr [v0] -> v30
    - stack=[v30, v16, v0, <RET>], last_use=[v30]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v30, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v31
    - stack=[v31, v16, v0, <RET>], last_use=[v31]
      ptr_to_int [v31] -> v32
    - stack=[v32, v16, v0, <RET>], last_use=[v32]
      int_to_ptr [v32] -> v33
    - stack=[v33, v16, v0, <RET>], last_use=[v33]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v33, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v34
    - stack=[v34, v16, v0, <RET>], last_use=[v34]
      ptr_to_int [v34] -> v35
    - stack=[v35, v16, v0, <RET>], last_use=[v35]
      mload [v35] -> v36
    - stack=[v36, v16, v0, <RET>]
      pre: [DUP3]
      int_to_ptr [v0] -> v37
    - stack=[v37, v36, v16, v0, <RET>], last_use=[v37]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v37, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v38
    - stack=[v38, v36, v16, v0, <RET>], last_use=[v38]
      ptr_to_int [v38] -> v39
    - stack=[v39, v36, v16, v0, <RET>], last_use=[v39]
      int_to_ptr [v39] -> v40
    - stack=[v40, v36, v16, v0, <RET>], last_use=[v40]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v40, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v41
    - stack=[v41, v36, v16, v0, <RET>], last_use=[v41]
      ptr_to_int [v41] -> v42
    - stack=[v42, v36, v16, v0, <RET>], last_use=[v42]
      mload [v42] -> v43
    - stack=[v43, v36, v16, v0, <RET>], last_use=[v36, v43]
      add [v43, v36] -> v56
    - stack=[v56, v16, v0, <RET>], last_use=[v56]
      evm_calldata_load [v56] -> v57
    - stack=[v57, v16, v0, <RET>], last_use=[v0]
      pre: [SWAP1, SWAP2]
      int_to_ptr [v0] -> v45
    - stack=[v45, v57, v16, <RET>], last_use=[v45]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v45, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v46
    - stack=[v46, v57, v16, <RET>], last_use=[v46]
      ptr_to_int [v46] -> v47
    - stack=[v47, v57, v16, <RET>], last_use=[v47]
      int_to_ptr [v47] -> v48
    - stack=[v48, v57, v16, <RET>], last_use=[v48]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v48, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v49
    - stack=[v49, v57, v16, <RET>], last_use=[v49]
      ptr_to_int [v49] -> v50
    - stack=[v50, v57, v16, <RET>], last_use=[v16, v50]
      pre: [SWAP1, SWAP2, SWAP1]
      mstore [v50, v16]
    - stack=[v57, <RET>]
      return [v57]

// func private %solencoder_h1b9228b90dad6928_ensure_init(v0.i256, v1.i256)
  block0 P=[v0, v1] T=[]
    - stack=[v0, v1, <RET>]
      pre: [DUP1]
      int_to_ptr [v0] -> v2
    - stack=[v2, v0, v1, <RET>], last_use=[v2]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v2, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v3
    - stack=[v3, v0, v1, <RET>], last_use=[v3]
      ptr_to_int [v3] -> v4
    - stack=[v4, v0, v1, <RET>], last_use=[v4]
      mload [v4] -> v5
    - stack=[v5, v0, v1, <RET>], last_use=[v5]
      is_zero [v5] -> v25
    - stack=[v25, v0, v1, <RET>], last_use=[v25]
      zext [v25] -> v26
    - stack=[v26, v0, v1, <RET>], last_use=[v26]
      is_zero [v26] -> v27
    - stack=[v27, v0, v1, <RET>], last_use=[v27]
      is_zero [v27] -> v8
    - stack=[v8, v0, v1, <RET>]
      br [v8] -> [block1, block3]
  block1 P=[] T=[v0, v1]
    inherited from block0: [v0, v1, <RET>]
    - stack=[v0, v1, <RET>]
      pre: [DUP2]
      evm_malloc [v1] -> v9
    - stack=[v9, v0, v1, <RET>], last_use=[v9]
      ptr_to_int [v9] -> v10
    - stack=[v10, v0, v1, <RET>]
      pre: [DUP2]
      int_to_ptr [v0] -> v11
    - stack=[v11, v10, v0, v1, <RET>], last_use=[v11]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v11, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v12
    - stack=[v12, v10, v0, v1, <RET>], last_use=[v12]
      ptr_to_int [v12] -> v13
    - stack=[v13, v10, v0, v1, <RET>], last_use=[v13]
      pre: [DUP2, SWAP1]
      mstore [v13, v10]
    - stack=[v10, v0, v1, <RET>]
      pre: [DUP2]
      int_to_ptr [v0] -> v14
    - stack=[v14, v10, v0, v1, <RET>], last_use=[v14]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v14, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v15
    - stack=[v15, v10, v0, v1, <RET>], last_use=[v15]
      ptr_to_int [v15] -> v16
    - stack=[v16, v10, v0, v1, <RET>], last_use=[v16]
      pre: [DUP2, SWAP1]
      mstore [v16, v10]
    - stack=[v10, v0, v1, <RET>], last_use=[v1, v10]
      pre: [SWAP1, SWAP2]
      add [v1, v10] -> v17
    - stack=[v17, v0, <RET>], last_use=[v0]
      pre: [SWAP1]
      int_to_ptr [v0] -> v18
    - stack=[v18, v17, <RET>], last_use=[v18]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 2 }), SWAP2]
      gep [v18, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 2 }] -> v19
    - stack=[v19, v17, <RET>], last_use=[v19]
      ptr_to_int [v19] -> v20
    - stack=[v20, v17, <RET>], last_use=[v17, v20]
      mstore [v20, v17]
    - stack=[<RET>]
      jump -> block2
  block3 P=[] T=[]
    inherited from block0: [v0x, v1x, <RET>]
    - stack=[v0x, v1x, <RET>]
      cleanup: [POP, POP]
      jump -> block2
  block2 P=[] T=[]
    - stack=[<RET>]
      return []

// func private %soldecoder_i__ha12a03fcb5ba844b_abidecoder_h638151350e80a086_read_word__MemoryBytes_h1e381015a9b0111b__59e0d528d54cca1b(v0.i256) -> i256
  block0 P=[v0] T=[]
    - stack=[v0, <RET>]
      pre: [DUP1]
      int_to_ptr [v0] -> v1
    - stack=[v1, v0, <RET>], last_use=[v1]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v1, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v2
    - stack=[v2, v0, <RET>], last_use=[v2]
      ptr_to_int [v2] -> v3
    - stack=[v3, v0, <RET>], last_use=[v3]
      int_to_ptr [v3] -> v4
    - stack=[v4, v0, <RET>], last_use=[v4]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v4, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v5
    - stack=[v5, v0, <RET>], last_use=[v5]
      ptr_to_int [v5] -> v6
    - stack=[v6, v0, <RET>], last_use=[v6]
      int_to_ptr [v6] -> v52
    - stack=[v52, v0, <RET>], last_use=[v52]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v52, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v53
    - stack=[v53, v0, <RET>], last_use=[v53]
      ptr_to_int [v53] -> v54
    - stack=[v54, v0, <RET>], last_use=[v54]
      mload [v54] -> v55
    - stack=[v55, v0, <RET>]
      pre: [DUP2]
      int_to_ptr [v0] -> v8
    - stack=[v8, v55, v0, <RET>], last_use=[v8]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v8, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v9
    - stack=[v9, v55, v0, <RET>], last_use=[v9]
      ptr_to_int [v9] -> v10
    - stack=[v10, v55, v0, <RET>], last_use=[v10]
      int_to_ptr [v10] -> v11
    - stack=[v11, v55, v0, <RET>], last_use=[v11]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v11, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v12
    - stack=[v12, v55, v0, <RET>], last_use=[v12]
      ptr_to_int [v12] -> v13
    - stack=[v13, v55, v0, <RET>], last_use=[v13]
      mload [v13] -> v14
    - stack=[v14, v55, v0, <RET>]
      pre: [DUP1, PUSH(I256 { is_negative: false, abs: 32 })]
      add [I256 { is_negative: false, abs: 32 }, v14] -> v15
    - stack=[v15, v14, v55, v0, <RET>]
      pre: [DUP4]
      int_to_ptr [v0] -> v16
    - stack=[v16, v15, v14, v55, v0, <RET>], last_use=[v16]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v16, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v17
    - stack=[v17, v15, v14, v55, v0, <RET>], last_use=[v17]
      ptr_to_int [v17] -> v18
    - stack=[v18, v15, v14, v55, v0, <RET>], last_use=[v18]
      int_to_ptr [v18] -> v19
    - stack=[v19, v15, v14, v55, v0, <RET>], last_use=[v19]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v19, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v20
    - stack=[v20, v15, v14, v55, v0, <RET>], last_use=[v20]
      ptr_to_int [v20] -> v21
    - stack=[v21, v15, v14, v55, v0, <RET>], last_use=[v21]
      mload [v21] -> v22
    - stack=[v22, v15, v14, v55, v0, <RET>], last_use=[v14]
      pre: [SWAP2, PUSH(I256 { is_negative: false, abs: 32 })]
      add [I256 { is_negative: false, abs: 32 }, v14] -> v73
    - stack=[v73, v15, v22, v55, v0, <RET>], last_use=[v55]
      pre: [SWAP3, DUP4]
      gt [v73, v55] -> v74
    - stack=[v74, v15, v22, v73, v0, <RET>], last_use=[v74]
      zext [v74] -> v75
    - stack=[v75, v15, v22, v73, v0, <RET>], last_use=[v22, v73]
      pre: [SWAP2, SWAP1, SWAP3]
      lt [v73, v22] -> v76
    - stack=[v76, v75, v15, v0, <RET>], last_use=[v76]
      zext [v76] -> v77
    - stack=[v77, v75, v15, v0, <RET>], last_use=[v75, v77]
      or [v77, v75] -> v78
    - stack=[v78, v15, v0, <RET>], last_use=[v78]
      pre: [PUSH(I256 { is_negative: false, abs: 0 })]
      ne [I256 { is_negative: false, abs: 0 }, v78] -> v28
    - stack=[v28, v15, v0, <RET>]
      br [v28] -> [block1, block2]
  block1 P=[] T=[]
    inherited from block0: [v15x, v0x, <RET>]
    - stack=[v15x, v0x, <RET>]
      cleanup: [POP, POP]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 })]
      evm_revert [I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }]
  block2 P=[] T=[v15, v0]
    inherited from block0: [v15, v0, <RET>]
    - stack=[v15, v0, <RET>]
      pre: [DUP2]
      int_to_ptr [v0] -> v29
    - stack=[v29, v15, v0, <RET>], last_use=[v29]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v29, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v30
    - stack=[v30, v15, v0, <RET>], last_use=[v30]
      ptr_to_int [v30] -> v31
    - stack=[v31, v15, v0, <RET>], last_use=[v31]
      int_to_ptr [v31] -> v32
    - stack=[v32, v15, v0, <RET>], last_use=[v32]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v32, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v33
    - stack=[v33, v15, v0, <RET>], last_use=[v33]
      ptr_to_int [v33] -> v34
    - stack=[v34, v15, v0, <RET>], last_use=[v34]
      mload [v34] -> v35
    - stack=[v35, v15, v0, <RET>]
      pre: [DUP3]
      int_to_ptr [v0] -> v36
    - stack=[v36, v35, v15, v0, <RET>], last_use=[v36]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v36, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v37
    - stack=[v37, v35, v15, v0, <RET>], last_use=[v37]
      ptr_to_int [v37] -> v38
    - stack=[v38, v35, v15, v0, <RET>], last_use=[v38]
      int_to_ptr [v38] -> v39
    - stack=[v39, v35, v15, v0, <RET>], last_use=[v39]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v39, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v40
    - stack=[v40, v35, v15, v0, <RET>], last_use=[v40]
      ptr_to_int [v40] -> v41
    - stack=[v41, v35, v15, v0, <RET>], last_use=[v41]
      int_to_ptr [v41] -> v56
    - stack=[v56, v35, v15, v0, <RET>], last_use=[v56]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v56, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v57
    - stack=[v57, v35, v15, v0, <RET>], last_use=[v57]
      ptr_to_int [v57] -> v58
    - stack=[v58, v35, v15, v0, <RET>], last_use=[v58]
      mload [v58] -> v59
    - stack=[v59, v35, v15, v0, <RET>], last_use=[v35, v59]
      add [v59, v35] -> v60
    - stack=[v60, v15, v0, <RET>], last_use=[v60]
      mload [v60] -> v61
    - stack=[v61, v15, v0, <RET>], last_use=[v0]
      pre: [SWAP1, SWAP2]
      int_to_ptr [v0] -> v43
    - stack=[v43, v61, v15, <RET>], last_use=[v43]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v43, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v44
    - stack=[v44, v61, v15, <RET>], last_use=[v44]
      ptr_to_int [v44] -> v45
    - stack=[v45, v61, v15, <RET>], last_use=[v45]
      int_to_ptr [v45] -> v46
    - stack=[v46, v61, v15, <RET>], last_use=[v46]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v46, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v47
    - stack=[v47, v61, v15, <RET>], last_use=[v47]
      ptr_to_int [v47] -> v48
    - stack=[v48, v61, v15, <RET>], last_use=[v15, v48]
      pre: [SWAP1, SWAP2, SWAP1]
      mstore [v48, v15]
    - stack=[v61, <RET>]
      return [v61]

// func public %cursor_i__h140a998c67d6d59c_new__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563(v0.i256) -> i256
  block0 P=[v0] T=[]
    - stack=[v0, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 64 })]
      evm_malloc [I256 { is_negative: false, abs: 64 }] -> v1
    - stack=[v1, v0, <RET>], last_use=[v1]
      ptr_to_int [v1] -> v2
    - stack=[v2, v0, <RET>]
      pre: [DUP1]
      int_to_ptr [v2] -> v3
    - stack=[v3, v2, v0, <RET>], last_use=[v3]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v3, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v4
    - stack=[v4, v2, v0, <RET>], last_use=[v4]
      ptr_to_int [v4] -> v5
    - stack=[v5, v2, v0, <RET>], last_use=[v0, v5]
      pre: [SWAP1, SWAP2, SWAP1]
      mstore [v5, v0]
    - stack=[v2, <RET>]
      pre: [DUP1]
      int_to_ptr [v2] -> v6
    - stack=[v6, v2, <RET>], last_use=[v6]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v6, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v7
    - stack=[v7, v2, <RET>], last_use=[v7]
      ptr_to_int [v7] -> v8
    - stack=[v8, v2, <RET>], last_use=[v8]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), SWAP1]
      mstore [v8, I256 { is_negative: false, abs: 0 }]
    - stack=[v2, <RET>]
      return [v2]

// func public %cursor_i__h140a998c67d6d59c_fork__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563(v0.i256, v1.i256) -> i256
  block0 P=[v0, v1] T=[]
    - stack=[v0, v1, <RET>], last_use=[v0]
      int_to_ptr [v0] -> v2
    - stack=[v2, v1, <RET>], last_use=[v2]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v2, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v3
    - stack=[v3, v1, <RET>], last_use=[v3]
      ptr_to_int [v3] -> v4
    - stack=[v4, v1, <RET>], last_use=[v4]
      mload [v4] -> v5
    - stack=[v5, v1, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 64 })]
      evm_malloc [I256 { is_negative: false, abs: 64 }] -> v6
    - stack=[v6, v5, v1, <RET>], last_use=[v6]
      ptr_to_int [v6] -> v7
    - stack=[v7, v5, v1, <RET>]
      pre: [DUP1]
      int_to_ptr [v7] -> v8
    - stack=[v8, v7, v5, v1, <RET>], last_use=[v8]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 0 }), SWAP2]
      gep [v8, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 0 }] -> v9
    - stack=[v9, v7, v5, v1, <RET>], last_use=[v9]
      ptr_to_int [v9] -> v10
    - stack=[v10, v7, v5, v1, <RET>], last_use=[v5, v10]
      pre: [SWAP1, SWAP2, SWAP1]
      mstore [v10, v5]
    - stack=[v7, v1, <RET>]
      pre: [DUP1]
      int_to_ptr [v7] -> v11
    - stack=[v11, v7, v1, <RET>], last_use=[v11]
      pre: [PUSH(I256 { is_negative: false, abs: 0 }), PUSH(I256 { is_negative: false, abs: 1 }), SWAP2]
      gep [v11, I256 { is_negative: false, abs: 0 }, I256 { is_negative: false, abs: 1 }] -> v12
    - stack=[v12, v7, v1, <RET>], last_use=[v12]
      ptr_to_int [v12] -> v13
    - stack=[v13, v7, v1, <RET>], last_use=[v1, v13]
      pre: [SWAP1, SWAP2, SWAP1]
      mstore [v13, v1]
    - stack=[v7, <RET>]
      return [v7]

// func private %test_coin__StorPtr_Evm___207f35a85ac4062e()
test_coin__StorPtr_Evm___207f35a85ac4062e:
  block0:
    JUMPDEST
    PUSH0  // v2.i256 = call %create2__Evm_hef0af3106e109414_Coin_h690a60df6720eb85__139b6eceaab4e08e 0.i256 0.i256;
    PUSH0
    PUSH1 `pc + (4)`
    SWAP2
    PUSH1 FuncRef(10)
    JUMP
    JUMPDEST
    DUP1  // v69.i1 = is_zero v2;
    ISZERO
    ISZERO  // v70.i1 = is_zero v69;
    PUSH1 0x1 (1)  // v5.i256 = zext v70 i256;
    AND
    PUSH1 `pc + (4)`  // call %assert v5;
    SWAP1
    PUSH1 FuncRef(11)
    JUMP
    JUMPDEST
    PUSH1 0x40 (64)  // v8.*i8 = evm_malloc 64.i256;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP1  // v10.*@__fe_Credit_0 = int_to_ptr v9 *@__fe_Credit_0;
    PUSH0  // mstore v12 0.i256 i256;
    SWAP1
    MSTORE
    DUP1  // v14.*@__fe_Credit_0 = int_to_ptr v9 *@__fe_Credit_0;
    PUSH1 0x20 (32)  // v15.*i256 = gep v14 0.i256 1.i256;
    ADD
    PUSH1 0xa (10)  // mstore v16 10.i256 i256;
    SWAP1
    MSTORE
    DUP2  // v18.i256 = call %evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__Credit_h1b40c7da4bcceeac__9489dcd0a297a0c v2 100000.i256 0.i256 v9;
    SWAP1
    PUSH0
    PUSH3 0x186a0 (100000)
    PUSH1 `pc + (4)`
    SWAP4
    PUSH1 FuncRef(12)
    JUMP
    JUMPDEST
    PUSH1 0xa (10)  // v71.i1 = eq 10.i256 v18;
    EQ
    PUSH1 0x1 (1)  // v20.i256 = zext v71 i256;
    AND
    PUSH1 `pc + (4)`  // call %assert v20;
    SWAP1
    PUSH1 FuncRef(11)
    JUMP
    JUMPDEST
    PUSH1 0x40 (64)  // v21.*i8 = evm_malloc 64.i256;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP1  // v23.*@__fe_Credit_0 = int_to_ptr v22 *@__fe_Credit_0;
    PUSH1 0x1 (1)  // mstore v25 1.i256 i256;
    SWAP1
    MSTORE
    DUP1  // v27.*@__fe_Credit_0 = int_to_ptr v22 *@__fe_Credit_0;
    PUSH1 0x20 (32)  // v28.*i256 = gep v27 0.i256 1.i256;
    ADD
    PUSH1 0x5 (5)  // mstore v29 5.i256 i256;
    SWAP1
    MSTORE
    DUP2  // v30.i256 = call %evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__Credit_h1b40c7da4bcceeac__9489dcd0a297a0c v2 100000.i256 0.i256 v22;
    SWAP1
    PUSH0
    PUSH3 0x186a0 (100000)
    PUSH1 `pc + (4)`
    SWAP4
    PUSH1 FuncRef(12)
    JUMP
    JUMPDEST
    PUSH1 0x5 (5)  // v72.i1 = eq 5.i256 v30;
    EQ
    PUSH1 0x1 (1)  // v32.i256 = zext v72 i256;
    AND
    PUSH1 `pc + (4)`  // call %assert v32;
    SWAP1
    PUSH1 FuncRef(11)
    JUMP
    JUMPDEST
    PUSH1 0x40 (64)  // v33.*i8 = evm_malloc 64.i256;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP1  // v35.*@__fe_Transfer_1 = int_to_ptr v34 *@__fe_Transfer_1;
    PUSH0  // mstore v37 0.i256 i256;
    SWAP1
    MSTORE
    DUP1  // v39.*@__fe_Transfer_1 = int_to_ptr v34 *@__fe_Transfer_1;
    PUSH1 0x20 (32)  // v40.*i256 = gep v39 0.i256 1.i256;
    ADD
    PUSH1 0x3 (3)  // mstore v41 3.i256 i256;
    SWAP1
    MSTORE
    DUP2  // v42.i256 = call %evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__Transfer_hbe7d801e15d910f6__66cc42efa72ff9b1 v2 100000.i256 0.i256 v34;
    SWAP1
    PUSH0
    PUSH3 0x186a0 (100000)
    PUSH1 `pc + (4)`
    SWAP4
    PUSH1 FuncRef(13)
    JUMP
    JUMPDEST
    ISZERO  // v73.i1 = is_zero v42;
    PUSH1 0x1 (1)  // v44.i256 = zext v73 i256;
    AND
    PUSH1 `pc + (4)`  // call %assert v44;
    SWAP1
    PUSH1 FuncRef(11)
    JUMP
    JUMPDEST
    DUP1  // v45.i256 = call %evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__BalanceOf_h891837b06b5610d4__9cd8cdf578aad9be v2 100000.i256 0.i256 0.i256;
    PUSH0
    PUSH0
    PUSH3 0x186a0 (100000)
    PUSH1 `pc + (4)`
    SWAP4
    PUSH1 FuncRef(14)
    JUMP
    JUMPDEST
    PUSH1 0x7 (7)  // v74.i1 = eq 7.i256 v45;
    EQ
    PUSH1 0x1 (1)  // v48.i256 = zext v74 i256;
    AND
    PUSH1 `pc + (4)`  // call %assert v48;
    SWAP1
    PUSH1 FuncRef(11)
    JUMP
    JUMPDEST
    DUP1  // v49.i256 = call %evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__BalanceOf_h891837b06b5610d4__9cd8cdf578aad9be v2 100000.i256 0.i256 1.i256;
    PUSH1 0x1 (1)
    PUSH0
    PUSH3 0x186a0 (100000)
    PUSH1 `pc + (4)`
    SWAP4
    PUSH1 FuncRef(14)
    JUMP
    JUMPDEST
    PUSH1 0x8 (8)  // v75.i1 = eq 8.i256 v49;
    EQ
    PUSH1 0x1 (1)  // v52.i256 = zext v75 i256;
    AND
    PUSH1 `pc + (4)`  // call %assert v52;
    SWAP1
    PUSH1 FuncRef(11)
    JUMP
    JUMPDEST
    PUSH1 0x40 (64)  // v53.*i8 = evm_malloc 64.i256;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP1  // v55.*@__fe_Transfer_1 = int_to_ptr v54 *@__fe_Transfer_1;
    PUSH1 0x1 (1)  // mstore v57 1.i256 i256;
    SWAP1
    MSTORE
    DUP1  // v59.*@__fe_Transfer_1 = int_to_ptr v54 *@__fe_Transfer_1;
    PUSH1 0x20 (32)  // v60.*i256 = gep v59 0.i256 1.i256;
    ADD
    PUSH1 0x14 (20)  // mstore v61 20.i256 i256;
    SWAP1
    MSTORE
    DUP2  // v62.i256 = call %evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__Transfer_hbe7d801e15d910f6__66cc42efa72ff9b1 v2 100000.i256 0.i256 v54;
    SWAP1
    PUSH0
    PUSH3 0x186a0 (100000)
    PUSH1 `pc + (4)`
    SWAP4
    PUSH1 FuncRef(13)
    JUMP
    JUMPDEST
    PUSH1 0x1 (1)  // v76.i1 = eq 1.i256 v62;
    EQ
    PUSH1 0x1 (1)  // v64.i256 = zext v76 i256;
    AND
    PUSH1 `pc + (4)`  // call %assert v64;
    SWAP1
    PUSH1 FuncRef(11)
    JUMP
    JUMPDEST
    PUSH0  // v65.i256 = call %evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__TotalSupply_h7bb395110a25abc2__8d4065b5d6bedb33 v2 100000.i256 0.i256;
    PUSH3 0x186a0 (100000)
    PUSH1 `pc + (4)`
    SWAP3
    PUSH1 FuncRef(15)
    JUMP
    JUMPDEST
    PUSH1 0xf (15)  // v77.i1 = eq 15.i256 v65;
    EQ
    PUSH1 0x1 (1)  // v68.i256 = zext v77 i256;
    AND
    PUSH1 `pc + (4)`  // call %assert v68;
    SWAP1
    PUSH1 FuncRef(11)
    JUMP
    JUMPDEST
    PUSH0  // evm_return 0.i256 0.i256;
    PUSH0
    RETURN

// func private %__Coin_recv_0_0(v0.i256, v1.i256) -> i256
__Coin_recv_0_0:
  block0:
    JUMPDEST
    DUP1  // v3.*@__fe_Credit_0 = int_to_ptr v0 *@__fe_Credit_0;
    MLOAD  // v6.i256 = mload v5 i256;
    SWAP1  // v7.*@__fe_Credit_0 = int_to_ptr v0 *@__fe_Credit_0;
    PUSH1 0x20 (32)  // v9.*i256 = gep v7 0.i256 1.i256;
    ADD
    MLOAD  // v11.i256 = mload v10 i256;
    SWAP1  // v35.i1 = is_zero v6;
    ISZERO
    PUSH1 0x1 (1)  // v36.i256 = zext v35 i256;
    AND
    PUSH1 0x1 (1)  // v14.i1 = eq 1.i256 v36;
    EQ
    ISZERO  // br v14 block1 block2;
    PUSH1 block2
    JUMPI
  block1:
    DUP2  // v17.i256 = evm_sload v1;
    SLOAD
    DUP2  // v19.i256 = add v17 v11;
    ADD
    DUP3  // evm_sstore v1 v19;
    SSTORE
    DUP2  // v21.i256 = add 2.i256 v1;
    PUSH1 0x2 (2)
    ADD
    SLOAD  // v22.i256 = evm_sload v21;
    ADD  // v23.i256 = add v22 v11;
    DUP2  // v24.i256 = add 2.i256 v1;
    PUSH1 0x2 (2)
    ADD
    SSTORE  // evm_sstore v24 v23;
    SLOAD  // v25.i256 = evm_sload v1;
    SWAP1  // return v25;
    JUMP
  block2:
    JUMPDEST
    DUP2  // v27.i256 = add 1.i256 v1;
    PUSH1 0x1 (1)
    ADD
    SLOAD  // v28.i256 = evm_sload v27;
    DUP2  // v30.i256 = add v28 v11;
    ADD
    DUP3  // v31.i256 = add 1.i256 v1;
    PUSH1 0x1 (1)
    ADD
    SSTORE  // evm_sstore v31 v30;
    DUP2  // v32.i256 = add 2.i256 v1;
    PUSH1 0x2 (2)
    ADD
    SLOAD  // v33.i256 = evm_sload v32;
    ADD  // v34.i256 = add v33 v11;
    DUP2  // v35.i256 = add 2.i256 v1;
    PUSH1 0x2 (2)
    ADD
    SSTORE  // evm_sstore v35 v34;
    PUSH1 0x1 (1)  // v36.i256 = add 1.i256 v1;
    ADD
    SLOAD  // v37.i256 = evm_sload v36;
    SWAP1  // return v37;
    JUMP

// func private %__Coin_recv_0_1(v0.i256, v1.i256) -> i256
__Coin_recv_0_1:
  block0:
    JUMPDEST
    DUP1  // v3.*@__fe_Transfer_1 = int_to_ptr v0 *@__fe_Transfer_1;
    MLOAD  // v6.i256 = mload v5 i256;
    SWAP1  // v7.*@__fe_Transfer_1 = int_to_ptr v0 *@__fe_Transfer_1;
    PUSH1 0x20 (32)  // v9.*i256 = gep v7 0.i256 1.i256;
    ADD
    MLOAD  // v11.i256 = mload v10 i256;
    SWAP1  // v38.i1 = is_zero v6;
    ISZERO
    PUSH1 0x1 (1)  // v39.i256 = zext v38 i256;
    AND
    PUSH1 0x1 (1)  // v14.i1 = eq 1.i256 v39;
    EQ
    ISZERO  // br v14 block1 block2;
    PUSH1 block2
    JUMPI
  block1:
    DUP2  // v17.i256 = evm_sload v1;
    SLOAD
    DUP2  // v41.i1 = lt v17 v11;
    SWAP1
    LT
    PUSH1 0x1 (1)  // v42.i256 = zext v41 i256;
    AND
    ISZERO  // v43.i1 = is_zero v42;
    PUSH1 block4  // br v21 block3 block4;
    JUMPI
  block2:
    JUMPDEST
    DUP2  // v23.i256 = add 1.i256 v1;
    PUSH1 0x1 (1)
    ADD
    SLOAD  // v24.i256 = evm_sload v23;
    DUP2  // v45.i1 = lt v24 v11;
    SWAP1
    LT
    PUSH1 0x1 (1)  // v46.i256 = zext v45 i256;
    AND
    ISZERO  // v47.i1 = is_zero v46;
    PUSH1 block6  // br v28 block5 block6;
    JUMPI
  block3:
    POP  // return 1.i256;
    POP
    PUSH1 0x1 (1)
    SWAP1
    JUMP
  block4:
    JUMPDEST
    DUP2  // v30.i256 = evm_sload v1;
    SLOAD
    DUP2  // v32.i256 = sub v30 v11;
    SWAP1
    SUB
    DUP3  // evm_sstore v1 v32;
    SSTORE
    DUP2  // v33.i256 = add 1.i256 v1;
    PUSH1 0x1 (1)
    ADD
    SLOAD  // v34.i256 = evm_sload v33;
    ADD  // v35.i256 = add v34 v11;
    SWAP1  // v36.i256 = add 1.i256 v1;
    PUSH1 0x1 (1)
    ADD
    SSTORE  // evm_sstore v36 v35;
    PUSH0  // return 0.i256;
    SWAP1
    JUMP
  block5:
    POP  // return 1.i256;
    POP
    PUSH1 0x1 (1)
    SWAP1
    JUMP
  block6:
    JUMPDEST
    DUP2  // v38.i256 = add 1.i256 v1;
    PUSH1 0x1 (1)
    ADD
    SLOAD  // v39.i256 = evm_sload v38;
    DUP2  // v41.i256 = sub v39 v11;
    SWAP1
    SUB
    DUP3  // v42.i256 = add 1.i256 v1;
    PUSH1 0x1 (1)
    ADD
    SSTORE  // evm_sstore v42 v41;
    DUP2  // v43.i256 = evm_sload v1;
    SLOAD
    ADD  // v44.i256 = add v43 v11;
    SWAP1  // evm_sstore v1 v44;
    SSTORE
    PUSH0  // return 0.i256;
    SWAP1
    JUMP

// func private %__Coin_recv_0_2(v0.i256, v1.i256) -> i256
__Coin_recv_0_2:
  block0:
    JUMPDEST
    ISZERO  // v12.i1 = is_zero v0;
    PUSH1 0x1 (1)  // v13.i256 = zext v12 i256;
    AND
    PUSH1 0x1 (1)  // v6.i1 = eq 1.i256 v13;
    EQ
    ISZERO  // br v6 block1 block2;
    PUSH1 block2
    JUMPI
  block1:
    SLOAD  // v9.i256 = evm_sload v1;
    SWAP1  // return v9;
    JUMP
  block2:
    JUMPDEST
    PUSH1 0x1 (1)  // v11.i256 = add 1.i256 v1;
    ADD
    SLOAD  // v12.i256 = evm_sload v11;
    SWAP1  // return v12;
    JUMP

// func private %__Coin_init()
__Coin_init:
  block0:
    JUMPDEST
    PUSH0 0x0 (0)  // v2.i256 = sym_addr &__Coin_runtime;
    PUSH0 0x0 (0)  // v3.i256 = sym_size &__Coin_runtime;
    CODESIZE  // v4.i256 = evm_code_size;
    DUP2  // v39.i256 = add v2 v3;
    DUP4
    ADD
    DUP2  // v40.i1 = lt v4 v39;
    LT
    PUSH1 0x1 (1)  // v41.i256 = zext v40 i256;
    AND
    ISZERO  // v42.i1 = is_zero v41;
    PUSH1 block2  // br v9 block1 block2;
    JUMPI
  block1:
    POP  // evm_revert 0.i256 0.i256;
    POP
    POP
    PUSH0
    PUSH0
    REVERT
  block2:
    JUMPDEST
    DUP2  // v43.i256 = add v2 v3;
    DUP4
    ADD
    DUP2  // v17.i256 = sub v4 v43;
    SUB
    PUSH1 0x1f (31)  // v18.*i8 = evm_malloc v17;
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP3  // v20.i256 = add v2 v3;
    DUP5
    ADD
    DUP4  // v44.i256 = add v2 v3;
    DUP6
    ADD
    DUP4  // v22.i256 = sub v4 v44;
    SUB
    SWAP1  // evm_code_copy v19 v20 v22;
    DUP3
    CODECOPY
    PUSH1 0x40 (64)  // v24.*i8 = evm_malloc 64.i256;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP1  // v26.*@__fe_MemoryBytes_2 = int_to_ptr v25 *@__fe_MemoryBytes_2;
    SWAP1  // mstore v28 v19 i256;
    SWAP2
    SWAP1
    MSTORE
    DUP3  // v45.i256 = add v2 v3;
    DUP5
    ADD
    SWAP1  // v30.i256 = sub v4 v45;
    SWAP2
    SUB
    DUP2  // v31.*@__fe_MemoryBytes_2 = int_to_ptr v25 *@__fe_MemoryBytes_2;
    PUSH1 0x20 (32)  // v33.*i256 = gep v31 0.i256 1.i256;
    ADD
    MSTORE  // mstore v34 v30 i256;
    PUSH1 `pc + (4)`  // v35.i256 = call %soldecoder_i__ha12a03fcb5ba844b_new__MemoryBytes_h1e381015a9b0111b__59e0d528d54cca1b v25;
    SWAP1
    PUSH1 FuncRef(35)
    JUMP
    JUMPDEST
    POP  // evm_sstore 0.i256 0.i256;
    PUSH0
    PUSH0
    SSTORE
    PUSH0  // evm_sstore 1.i256 0.i256;
    PUSH1 0x1 (1)
    SSTORE
    PUSH0  // evm_sstore 2.i256 0.i256;
    PUSH1 0x2 (2)
    SSTORE
    DUP1  // evm_code_copy 0.i256 v2 v3;
    SWAP2
    PUSH0
    CODECOPY
    PUSH0  // evm_return 0.i256 v3;
    RETURN

// func private %__Coin_runtime()
__Coin_runtime:
  block0:
    JUMPDEST
    PUSH1 `pc + (3)`  // v2.i256 = call %runtime_selector__Evm_hef0af3106e109414_Sol_hfd482bb803ad8c5f__e4e3f8d20b3805a2;
    PUSH1 FuncRef(21)
    JUMP
    JUMPDEST
    PUSH1 0x40 (64)  // v69.*i8 = evm_malloc 64.i256;
    POP
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1  // v71.*@__fe_Cursor_8 = int_to_ptr v70 *@__fe_Cursor_8;
    PUSH0  // mstore v73 0.i256 i256;
    SWAP1
    MSTORE
    DUP1  // v74.*@__fe_Cursor_8 = int_to_ptr v70 *@__fe_Cursor_8;
    PUSH1 0x20 (32)  // v75.*i256 = gep v74 0.i256 1.i256;
    ADD
    PUSH0  // mstore v76 0.i256 i256;
    SWAP1
    MSTORE
    MLOAD  // v80.i256 = mload v79 i256;
    PUSH1 0x40 (64)  // v81.*i8 = evm_malloc 64.i256;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP1  // v83.*@__fe_Cursor_8 = int_to_ptr v82 *@__fe_Cursor_8;
    SWAP1  // mstore v85 v80 i256;
    SWAP2
    SWAP1
    MSTORE
    DUP1  // v86.*@__fe_Cursor_8 = int_to_ptr v82 *@__fe_Cursor_8;
    PUSH1 0x20 (32)  // v87.*i256 = gep v86 0.i256 1.i256;
    ADD
    PUSH1 0x4 (4)  // mstore v88 4.i256 i256;
    SWAP1
    MSTORE
    PUSH1 0x60 (96)  // v50.*i8 = evm_malloc 96.i256;
    POP
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP2  // v52.*@__fe_Cursor_8 = int_to_ptr v82 *@__fe_Cursor_8;
    MLOAD  // v55.i256 = mload v54 i256;
    DUP2  // v56.*@__fe_SolDecoder_9 = int_to_ptr v51 *@__fe_SolDecoder_9;
    MSTORE  // mstore v58 v55 i256;
    SWAP1  // v59.*@__fe_Cursor_8 = int_to_ptr v82 *@__fe_Cursor_8;
    PUSH1 0x20 (32)  // v60.*i256 = gep v59 0.i256 1.i256;
    ADD
    MLOAD  // v62.i256 = mload v61 i256;
    DUP2  // v63.*@__fe_SolDecoder_9 = int_to_ptr v51 *@__fe_SolDecoder_9;
    PUSH1 0x20 (32)  // v64.*i256 = gep v63 0.i256 0.i256 1.i256;
    ADD
    MSTORE  // mstore v65 v62 i256;
    DUP1  // v66.*@__fe_SolDecoder_9 = int_to_ptr v51 *@__fe_SolDecoder_9;
    PUSH1 0x40 (64)  // v67.*i256 = gep v66 0.i256 1.i256;
    ADD
    PUSH1 0x4 (4)  // mstore v68 4.i256 i256;
    SWAP1
    MSTORE
    DUP2  // v8.i1 = eq 2877082652.i256 v2;
    PUSH4 0xab7ccc1c (2877082652)
    EQ
    ISZERO  // br v8 block2 block6;
    PUSH1 block6
    JUMPI
  block1:
    PUSH0  // evm_revert 0.i256 0.i256;
    PUSH0
    REVERT
  block2:
    SWAP1  // v24.i256 = call %soldecoder_i__ha12a03fcb5ba844b_abidecoder_h638151350e80a086_read_word__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563 v51;
    POP
    DUP1
    PUSH1 `pc + (4)`
    SWAP1
    PUSH1 FuncRef(59)
    JUMP
    JUMPDEST
    SWAP1  // v25.i256 = call %soldecoder_i__ha12a03fcb5ba844b_abidecoder_h638151350e80a086_read_word__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563 v51;
    PUSH1 `pc + (4)`
    SWAP1
    PUSH1 FuncRef(59)
    JUMP
    JUMPDEST
    PUSH1 0x40 (64)  // v26.*i8 = evm_malloc 64.i256;
    POP
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1  // v28.*@__fe_Credit_0 = int_to_ptr v27 *@__fe_Credit_0;
    SWAP1  // mstore v30 v24 i256;
    SWAP3
    SWAP1
    MSTORE
    DUP2  // v31.*@__fe_Credit_0 = int_to_ptr v27 *@__fe_Credit_0;
    PUSH1 0x20 (32)  // v32.*i256 = gep v31 0.i256 1.i256;
    ADD
    MSTORE  // mstore v33 v25 i256;
    PUSH0  // v15.i256 = call %__Coin_recv_0_0 v27 0.i256;
    PUSH1 `pc + (4)`
    SWAP2
    PUSH1 FuncRef(2)
    JUMP
    JUMPDEST
    PUSH1 `pc + (4)`  // call %return_value__Evm_hef0af3106e109414_Sol_hfd482bb803ad8c5f_u256__c4b26908c66ef75f v15;
    SWAP1
    PUSH1 FuncRef(24)
    JUMP
    JUMPDEST
    INVALID  // unreachable;
  block3:
    SWAP1  // v34.i256 = call %soldecoder_i__ha12a03fcb5ba844b_abidecoder_h638151350e80a086_read_word__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563 v51;
    POP
    DUP1
    PUSH1 `pc + (4)`
    SWAP1
    PUSH1 FuncRef(59)
    JUMP
    JUMPDEST
    SWAP1  // v35.i256 = call %soldecoder_i__ha12a03fcb5ba844b_abidecoder_h638151350e80a086_read_word__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563 v51;
    PUSH1 `pc + (4)`
    SWAP1
    PUSH1 FuncRef(59)
    JUMP
    JUMPDEST
    PUSH1 0x40 (64)  // v36.*i8 = evm_malloc 64.i256;
    POP
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1  // v38.*@__fe_Transfer_1 = int_to_ptr v37 *@__fe_Transfer_1;
    SWAP1  // mstore v40 v34 i256;
    SWAP3
    SWAP1
    MSTORE
    DUP2  // v41.*@__fe_Transfer_1 = int_to_ptr v37 *@__fe_Transfer_1;
    PUSH1 0x20 (32)  // v42.*i256 = gep v41 0.i256 1.i256;
    ADD
    MSTORE  // mstore v43 v35 i256;
    PUSH0  // v19.i256 = call %__Coin_recv_0_1 v37 0.i256;
    PUSH1 `pc + (4)`
    SWAP2
    PUSH1 FuncRef(3)
    JUMP
    JUMPDEST
    PUSH1 `pc + (4)`  // call %return_value__Evm_hef0af3106e109414_Sol_hfd482bb803ad8c5f_u256__c4b26908c66ef75f v19;
    SWAP1
    PUSH1 FuncRef(24)
    JUMP
    JUMPDEST
    INVALID  // unreachable;
  block4:
    SWAP1  // v21.i256 = call %soldecoder_i__ha12a03fcb5ba844b_abidecoder_h638151350e80a086_read_word__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563 v51;
    POP
    PUSH1 `pc + (4)`
    SWAP1
    PUSH1 FuncRef(59)
    JUMP
    JUMPDEST
    PUSH0  // v23.i256 = call %__Coin_recv_0_2 v21 0.i256;
    PUSH1 `pc + (4)`
    SWAP2
    PUSH1 FuncRef(4)
    JUMP
    JUMPDEST
    PUSH1 `pc + (4)`  // call %return_value__Evm_hef0af3106e109414_Sol_hfd482bb803ad8c5f_u256__c4b26908c66ef75f v23;
    SWAP1
    PUSH1 FuncRef(24)
    JUMP
    JUMPDEST
    INVALID  // unreachable;
  block5:
    JUMPDEST
    PUSH1 0x2 (2)  // v46.i256 = evm_sload 2.i256;
    SLOAD
    PUSH1 `pc + (4)`  // call %return_value__Evm_hef0af3106e109414_Sol_hfd482bb803ad8c5f_u256__c4b26908c66ef75f v46;
    SWAP1
    PUSH1 FuncRef(24)
    JUMP
    JUMPDEST
    INVALID  // unreachable;
  block6:
    JUMPDEST
    DUP2  // v9.i1 = eq 217554442.i256 v2;
    PUSH4 0xcf79e0a (217554442)
    EQ
    ISZERO  // br v9 block3 block7;
    PUSH1 block7
    JUMPI
  block7:
    JUMPDEST
    DUP2  // v10.i1 = eq 1818602213.i256 v2;
    PUSH4 0x6c65aae5 (1818602213)
    EQ
    ISZERO  // br v10 block4 block8;
    PUSH1 block8
    JUMPI
  block8:
    JUMPDEST
    POP  // v11.i1 = eq 960555502.i256 v2;
    PUSH4 0x3940e9ee (960555502)
    EQ
    PUSH1 block5  // br v11 block5 block1;
    JUMPI

// func private %create2__Evm_hef0af3106e109414_Coin_h690a60df6720eb85__139b6eceaab4e08e(v0.i256, v1.i256) -> i256
create2__Evm_hef0af3106e109414_Coin_h690a60df6720eb85__139b6eceaab4e08e:
  block0:
    JUMPDEST
    PUSH0 0x0 (0)  // v31.i256 = sym_size &__Coin_init;
    PUSH0 0x0 (0)  // v32.i256 = sym_addr &__Coin_init;
    DUP2  // v6.*i8 = evm_malloc v31;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP1  // evm_code_copy v7 v32 v31;
    SWAP2
    DUP4
    SWAP2
    CODECOPY
    DUP1  // v8.i256 = add v31 v7;
    DUP3
    ADD
    PUSH1 0x60 (96)  // v10.*i8 = evm_malloc 96.i256;
    POP
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1  // v12.*@__fe_SolEncoder_3 = int_to_ptr v11 *@__fe_SolEncoder_3;
    DUP3  // mstore v14 v8 i256;
    SWAP1
    MSTORE
    DUP1  // v15.*@__fe_SolEncoder_3 = int_to_ptr v11 *@__fe_SolEncoder_3;
    PUSH1 0x20 (32)  // v17.*i256 = gep v15 0.i256 1.i256;
    ADD
    DUP3  // mstore v18 v8 i256;
    SWAP1
    MSTORE
    PUSH1 0x40 (64)  // v22.*i256 = gep v20 0.i256 2.i256;
    ADD
    MSTORE  // mstore v23 v8 i256;
    SWAP1  // v33.i256 = evm_create2 v0 v7 v31 v1;
    SWAP2
    CREATE2
    DUP1  // v35.i1 = is_zero v33;
    ISZERO
    PUSH1 0x1 (1)  // v36.i256 = zext v35 i256;
    AND
    ISZERO  // v37.i1 = is_zero v36;
    PUSH1 block2  // br v27 block1 block2;
    JUMPI
  block1:
    POP  // v28.i256 = evm_return_data_size;
    RETURNDATASIZE
    DUP1  // v29.*i8 = evm_malloc v28;
    POP
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP2  // evm_return_data_copy v30 0.i256 v28;
    PUSH0
    DUP3
    RETURNDATACOPY
    REVERT  // evm_revert v30 v28;
  block2:
    JUMPDEST
    SWAP1  // return v33;
    JUMP

// func public %assert(v0.i256)
assert:
  block0:
    JUMPDEST
    ISZERO  // v6.i1 = is_zero v0;
    PUSH1 0x1 (1)  // v7.i256 = zext v6 i256;
    AND
    ISZERO  // v8.i1 = is_zero v7;
    PUSH1 block2  // br v4 block1 block2;
    JUMPI
  block1:
    PUSH0  // evm_revert 0.i256 0.i256;
    PUSH0
    REVERT
  block2:
    JUMPDEST
    JUMP  // return;

// func private %evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__Credit_h1b40c7da4bcceeac__9489dcd0a297a0c(v0.i256, v1.i256, v2.i256, v3.i256) -> i256
evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__Credit_h1b40c7da4bcceeac__9489dcd0a297a0c:
  block0:
    JUMPDEST
    PUSH1 0x40 (64)  // v55.i256 = mload 64.i32 i256;
    MLOAD
    PUSH1 `pc + (3)`  // v28.i256 = call %solencoder_h1b9228b90dad6928_new;
    PUSH1 FuncRef(48)
    JUMP
    JUMPDEST
    DUP1  // call %solencoder_h1b9228b90dad6928_ensure_init v28 68.i256;
    PUSH1 0x44 (68)
    PUSH1 `pc + (4)`
    SWAP2
    PUSH1 FuncRef(60)
    JUMP
    JUMPDEST
    DUP1  // v33.*@__fe_SolEncoder_3 = int_to_ptr v28 *@__fe_SolEncoder_3;
    MLOAD  // v36.i256 = mload v35 i256;
    PUSH32 0xab7ccc1c00000000000000000000000000000000000000000000000000000000 (77565994854904324023937311223486449794568501960910038851531794862588750200832)  // mstore v36 -38226094382411871399633673785201458058701482704730525187925789145324379439104.i256 i256;
    DUP2
    MSTORE
    PUSH1 0x4 (4)  // v31.i256 = add 4.i256 v36;
    ADD
    DUP2  // v37.*@__fe_SolEncoder_3 = int_to_ptr v28 *@__fe_SolEncoder_3;
    PUSH1 0x20 (32)  // v38.*i256 = gep v37 0.i256 1.i256;
    ADD
    MSTORE  // mstore v39 v31 i256;
    DUP6  // v40.*@__fe_Credit_0 = int_to_ptr v3 *@__fe_Credit_0;
    MLOAD  // v43.i256 = mload v42 i256;
    DUP7  // v44.*@__fe_Credit_0 = int_to_ptr v3 *@__fe_Credit_0;
    PUSH1 0x20 (32)  // v45.*i256 = gep v44 0.i256 1.i256;
    ADD
    MLOAD  // v47.i256 = mload v46 i256;
    SWAP1  // call %u256_h3271ca15373d4483_encode_hab7243eccf2714fb_encode__Sol_hfd482bb803ad8c5f_SolEncoder_h1b9228b90dad6928__1a070c3866d16383 v43 v28;
    DUP3
    PUSH1 `pc + (4)`
    SWAP2
    PUSH1 FuncRef(45)
    JUMP
    JUMPDEST
    DUP2  // call %u256_h3271ca15373d4483_encode_hab7243eccf2714fb_encode__Sol_hfd482bb803ad8c5f_SolEncoder_h1b9228b90dad6928__1a070c3866d16383 v47 v28;
    PUSH1 `pc + (4)`
    SWAP2
    PUSH1 FuncRef(45)
    JUMP
    JUMPDEST
    PUSH1 `pc + (4)`  // v32.i256 = call %solencoder_h1b9228b90dad6928_abiencoder_hffd58d20d4321024_finish v28;
    SWAP1
    PUSH1 FuncRef(46)
    JUMP
    JUMPDEST
    DUP1  // v7.*@__fe_tuple_4 = int_to_ptr v32 *@__fe_tuple_4;
    MLOAD  // v10.i256 = mload v9 i256;
    SWAP1  // v11.*@__fe_tuple_4 = int_to_ptr v32 *@__fe_tuple_4;
    PUSH1 0x20 (32)  // v13.*i256 = gep v11 0.i256 1.i256;
    ADD
    MLOAD  // v15.i256 = mload v14 i256;
    PUSH0  // v16.i256 = evm_call v1 v0 v2 v10 v15 0.i256 0.i256;
    PUSH0
    SWAP1
    SWAP2
    SWAP1
    SWAP2
    SWAP3
    DUP8
    DUP7
    DUP9
    CALL
    RETURNDATASIZE  // v17.i256 = evm_return_data_size;
    DUP1  // v18.*i8 = evm_malloc v17;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP2  // evm_return_data_copy v19 0.i256 v17;
    PUSH0
    DUP3
    RETURNDATACOPY
    SWAP1  // v51.i1 = is_zero v16;
    SWAP2
    ISZERO
    PUSH1 0x1 (1)  // v52.i256 = zext v51 i256;
    AND
    ISZERO  // v53.i1 = is_zero v52;
    PUSH1 block2  // br v22 block1 block2;
    JUMPI
  block1:
    REVERT  // evm_revert v19 v17;
  block2:
    JUMPDEST
    SWAP1  // v27.i256 = call %decode_returndata__u256__3271ca15373d4483 v19 v17;
    PUSH1 `pc + (4)`
    SWAP2
    PUSH1 FuncRef(31)
    JUMP
    JUMPDEST
    SWAP1  // mstore 64.i32 v55 i256;
    PUSH1 0x40 (64)
    MSTORE
    SWAP4  // return v27;
    POP
    POP
    POP
    POP
    SWAP1
    JUMP

// func private %evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__Transfer_hbe7d801e15d910f6__66cc42efa72ff9b1(v0.i256, v1.i256, v2.i256, v3.i256) -> i256
evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__Transfer_hbe7d801e15d910f6__66cc42efa72ff9b1:
  block0:
    JUMPDEST
    PUSH1 0x40 (64)  // v55.i256 = mload 64.i32 i256;
    MLOAD
    PUSH1 `pc + (3)`  // v28.i256 = call %solencoder_h1b9228b90dad6928_new;
    PUSH1 FuncRef(48)
    JUMP
    JUMPDEST
    DUP1  // call %solencoder_h1b9228b90dad6928_ensure_init v28 68.i256;
    PUSH1 0x44 (68)
    PUSH1 `pc + (4)`
    SWAP2
    PUSH1 FuncRef(60)
    JUMP
    JUMPDEST
    DUP1  // v33.*@__fe_SolEncoder_3 = int_to_ptr v28 *@__fe_SolEncoder_3;
    MLOAD  // v36.i256 = mload v35 i256;
    PUSH32 0xcf79e0a00000000000000000000000000000000000000000000000000000000 (5865256153521717170471777043062137194249213065319226468487051471953667817472)  // mstore v36 5865256153521717170471777043062137194249213065319226468487051471953667817472.i256 i256;
    DUP2
    MSTORE
    PUSH1 0x4 (4)  // v31.i256 = add 4.i256 v36;
    ADD
    DUP2  // v37.*@__fe_SolEncoder_3 = int_to_ptr v28 *@__fe_SolEncoder_3;
    PUSH1 0x20 (32)  // v38.*i256 = gep v37 0.i256 1.i256;
    ADD
    MSTORE  // mstore v39 v31 i256;
    DUP6  // v40.*@__fe_Transfer_1 = int_to_ptr v3 *@__fe_Transfer_1;
    MLOAD  // v43.i256 = mload v42 i256;
    DUP7  // v44.*@__fe_Transfer_1 = int_to_ptr v3 *@__fe_Transfer_1;
    PUSH1 0x20 (32)  // v45.*i256 = gep v44 0.i256 1.i256;
    ADD
    MLOAD  // v47.i256 = mload v46 i256;
    SWAP1  // call %u256_h3271ca15373d4483_encode_hab7243eccf2714fb_encode__Sol_hfd482bb803ad8c5f_SolEncoder_h1b9228b90dad6928__1a070c3866d16383 v43 v28;
    DUP3
    PUSH1 `pc + (4)`
    SWAP2
    PUSH1 FuncRef(45)
    JUMP
    JUMPDEST
    DUP2  // call %u256_h3271ca15373d4483_encode_hab7243eccf2714fb_encode__Sol_hfd482bb803ad8c5f_SolEncoder_h1b9228b90dad6928__1a070c3866d16383 v47 v28;
    PUSH1 `pc + (4)`
    SWAP2
    PUSH1 FuncRef(45)
    JUMP
    JUMPDEST
    PUSH1 `pc + (4)`  // v32.i256 = call %solencoder_h1b9228b90dad6928_abiencoder_hffd58d20d4321024_finish v28;
    SWAP1
    PUSH1 FuncRef(46)
    JUMP
    JUMPDEST
    DUP1  // v7.*@__fe_tuple_4 = int_to_ptr v32 *@__fe_tuple_4;
    MLOAD  // v10.i256 = mload v9 i256;
    SWAP1  // v11.*@__fe_tuple_4 = int_to_ptr v32 *@__fe_tuple_4;
    PUSH1 0x20 (32)  // v13.*i256 = gep v11 0.i256 1.i256;
    ADD
    MLOAD  // v15.i256 = mload v14 i256;
    PUSH0  // v16.i256 = evm_call v1 v0 v2 v10 v15 0.i256 0.i256;
    PUSH0
    SWAP1
    SWAP2
    SWAP1
    SWAP2
    SWAP3
    DUP8
    DUP7
    DUP9
    CALL
    RETURNDATASIZE  // v17.i256 = evm_return_data_size;
    DUP1  // v18.*i8 = evm_malloc v17;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP2  // evm_return_data_copy v19 0.i256 v17;
    PUSH0
    DUP3
    RETURNDATACOPY
    SWAP1  // v51.i1 = is_zero v16;
    SWAP2
    ISZERO
    PUSH1 0x1 (1)  // v52.i256 = zext v51 i256;
    AND
    ISZERO  // v53.i1 = is_zero v52;
    PUSH1 block2  // br v22 block1 block2;
    JUMPI
  block1:
    REVERT  // evm_revert v19 v17;
  block2:
    JUMPDEST
    SWAP1  // v27.i256 = call %decode_returndata__u256__3271ca15373d4483 v19 v17;
    PUSH1 `pc + (4)`
    SWAP2
    PUSH1 FuncRef(31)
    JUMP
    JUMPDEST
    SWAP1  // mstore 64.i32 v55 i256;
    PUSH1 0x40 (64)
    MSTORE
    SWAP4  // return v27;
    POP
    POP
    POP
    POP
    SWAP1
    JUMP

// func private %evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__BalanceOf_h891837b06b5610d4__9cd8cdf578aad9be(v0.i256, v1.i256, v2.i256, v3.i256) -> i256
evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__BalanceOf_h891837b06b5610d4__9cd8cdf578aad9be:
  block0:
    JUMPDEST
    PUSH1 0x40 (64)  // v47.i256 = mload 64.i32 i256;
    MLOAD
    PUSH1 `pc + (3)`  // v28.i256 = call %solencoder_h1b9228b90dad6928_new;
    PUSH1 FuncRef(48)
    JUMP
    JUMPDEST
    DUP1  // call %solencoder_h1b9228b90dad6928_ensure_init v28 36.i256;
    PUSH1 0x24 (36)
    PUSH1 `pc + (4)`
    SWAP2
    PUSH1 FuncRef(60)
    JUMP
    JUMPDEST
    DUP1  // v33.*@__fe_SolEncoder_3 = int_to_ptr v28 *@__fe_SolEncoder_3;
    MLOAD  // v36.i256 = mload v35 i256;
    PUSH32 0x6c65aae500000000000000000000000000000000000000000000000000000000 (49029418671242127934947299235358287917519191605832892196421926281513699115008)  // mstore v36 49029418671242127934947299235358287917519191605832892196421926281513699115008.i256 i256;
    DUP2
    MSTORE
    PUSH1 0x4 (4)  // v31.i256 = add 4.i256 v36;
    ADD
    DUP2  // v37.*@__fe_SolEncoder_3 = int_to_ptr v28 *@__fe_SolEncoder_3;
    PUSH1 0x20 (32)  // v38.*i256 = gep v37 0.i256 1.i256;
    ADD
    MSTORE  // mstore v39 v31 i256;
    SWAP5  // call %u256_h3271ca15373d4483_encode_hab7243eccf2714fb_encode__Sol_hfd482bb803ad8c5f_SolEncoder_h1b9228b90dad6928__1a070c3866d16383 v3 v28;
    DUP6
    PUSH1 `pc + (4)`
    SWAP2
    PUSH1 FuncRef(45)
    JUMP
    JUMPDEST
    SWAP1  // v32.i256 = call %solencoder_h1b9228b90dad6928_abiencoder_hffd58d20d4321024_finish v28;
    SWAP2
    SWAP3
    SWAP4
    PUSH1 `pc + (4)`
    SWAP1
    PUSH1 FuncRef(46)
    JUMP
    JUMPDEST
    DUP1  // v7.*@__fe_tuple_4 = int_to_ptr v32 *@__fe_tuple_4;
    MLOAD  // v10.i256 = mload v9 i256;
    SWAP1  // v11.*@__fe_tuple_4 = int_to_ptr v32 *@__fe_tuple_4;
    PUSH1 0x20 (32)  // v13.*i256 = gep v11 0.i256 1.i256;
    ADD
    MLOAD  // v15.i256 = mload v14 i256;
    PUSH0  // v16.i256 = evm_call v1 v0 v2 v10 v15 0.i256 0.i256;
    PUSH0
    SWAP1
    SWAP2
    SWAP1
    SWAP2
    SWAP3
    DUP8
    DUP7
    DUP9
    CALL
    RETURNDATASIZE  // v17.i256 = evm_return_data_size;
    DUP1  // v18.*i8 = evm_malloc v17;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP2  // evm_return_data_copy v19 0.i256 v17;
    PUSH0
    DUP3
    RETURNDATACOPY
    SWAP1  // v43.i1 = is_zero v16;
    SWAP2
    ISZERO
    PUSH1 0x1 (1)  // v44.i256 = zext v43 i256;
    AND
    ISZERO  // v45.i1 = is_zero v44;
    PUSH1 block2  // br v22 block1 block2;
    JUMPI
  block1:
    REVERT  // evm_revert v19 v17;
  block2:
    JUMPDEST
    SWAP1  // v27.i256 = call %decode_returndata__u256__3271ca15373d4483 v19 v17;
    PUSH1 `pc + (4)`
    SWAP2
    PUSH1 FuncRef(31)
    JUMP
    JUMPDEST
    SWAP1  // mstore 64.i32 v47 i256;
    PUSH1 0x40 (64)
    MSTORE
    SWAP3  // return v27;
    POP
    POP
    POP
    SWAP1
    JUMP

// func private %evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__TotalSupply_h7bb395110a25abc2__8d4065b5d6bedb33(v0.i256, v1.i256, v2.i256) -> i256
evm_hef0af3106e109414_call_h2e84dd1b94aea876_call__TotalSupply_h7bb395110a25abc2__8d4065b5d6bedb33:
  block0:
    JUMPDEST
    PUSH1 0x40 (64)  // v44.i256 = mload 64.i32 i256;
    MLOAD
    PUSH1 `pc + (3)`  // v26.i256 = call %solencoder_h1b9228b90dad6928_new;
    PUSH1 FuncRef(48)
    JUMP
    JUMPDEST
    DUP1  // call %solencoder_h1b9228b90dad6928_ensure_init v26 4.i256;
    PUSH1 0x4 (4)
    PUSH1 `pc + (4)`
    SWAP2
    PUSH1 FuncRef(60)
    JUMP
    JUMPDEST
    DUP1  // v31.*@__fe_SolEncoder_3 = int_to_ptr v26 *@__fe_SolEncoder_3;
    MLOAD  // v34.i256 = mload v33 i256;
    PUSH32 0x3940e9ee00000000000000000000000000000000000000000000000000000000 (25896525104758109717587551599753715025570125426639959714953863856948019986432)  // mstore v34 25896525104758109717587551599753715025570125426639959714953863856948019986432.i256 i256;
    DUP2
    MSTORE
    PUSH1 0x4 (4)  // v29.i256 = add 4.i256 v34;
    ADD
    DUP2  // v35.*@__fe_SolEncoder_3 = int_to_ptr v26 *@__fe_SolEncoder_3;
    PUSH1 0x20 (32)  // v36.*i256 = gep v35 0.i256 1.i256;
    ADD
    MSTORE  // mstore v37 v29 i256;
    PUSH1 `pc + (4)`  // v30.i256 = call %solencoder_h1b9228b90dad6928_abiencoder_hffd58d20d4321024_finish v26;
    SWAP1
    PUSH1 FuncRef(46)
    JUMP
    JUMPDEST
    DUP1  // v6.*@__fe_tuple_4 = int_to_ptr v30 *@__fe_tuple_4;
    MLOAD  // v9.i256 = mload v8 i256;
    SWAP1  // v10.*@__fe_tuple_4 = int_to_ptr v30 *@__fe_tuple_4;
    PUSH1 0x20 (32)  // v12.*i256 = gep v10 0.i256 1.i256;
    ADD
    MLOAD  // v14.i256 = mload v13 i256;
    PUSH0  // v15.i256 = evm_call v1 v0 v2 v9 v14 0.i256 0.i256;
    PUSH0
    SWAP1
    SWAP2
    SWAP1
    SWAP2
    SWAP3
    DUP8
    DUP7
    DUP9
    CALL
    RETURNDATASIZE  // v16.i256 = evm_return_data_size;
    DUP1  // v17.*i8 = evm_malloc v16;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP2  // evm_return_data_copy v18 0.i256 v16;
    PUSH0
    DUP3
    RETURNDATACOPY
    SWAP1  // v40.i1 = is_zero v15;
    SWAP2
    ISZERO
    PUSH1 0x1 (1)  // v41.i256 = zext v40 i256;
    AND
    ISZERO  // v42.i1 = is_zero v41;
    PUSH1 block2  // br v21 block1 block2;
    JUMPI
  block1:
    REVERT  // evm_revert v18 v16;
  block2:
    JUMPDEST
    SWAP1  // v26.i256 = call %decode_returndata__u256__3271ca15373d4483 v18 v16;
    PUSH1 `pc + (4)`
    SWAP2
    PUSH1 FuncRef(31)
    JUMP
    JUMPDEST
    SWAP1  // mstore 64.i32 v44 i256;
    PUSH1 0x40 (64)
    MSTORE
    SWAP3  // return v26;
    POP
    POP
    POP
    SWAP1
    JUMP

// func public %alloc(v0.i256) -> i256
alloc:
  block0:
    JUMPDEST
    PUSH1 0x40 (64)  // v3.i256 = mload 64.i256 i256;
    MLOAD
    PUSH1 0x80 (128)  // v5.i256 = mload 128.i256 i256;
    MLOAD
    DUP2  // v22.i1 = gt v5 v3;
    DUP2
    GT
    PUSH1 0x1 (1)  // v23.i256 = zext v22 i256;
    AND
    ISZERO  // v24.i1 = is_zero v23;
    PUSH1 block7  // br v8 block1 block7;
    JUMPI
  block1:
    SWAP1  // jump block2;
    POP
    PUSH1 block2
    JUMP
  block2:
    JUMPDEST
    DUP1  // v26.i1 = is_zero v10;
    ISZERO
    PUSH1 0x1 (1)  // v27.i256 = zext v26 i256;
    AND
    ISZERO  // v28.i1 = is_zero v27;
    PUSH1 block8  // br v13 block3 block8;
    JUMPI
  block3:
    POP  // v14.i256 = evm_msize;
    MSIZE
    PUSH1 block4  // jump block4;
    JUMP
  block4:
    JUMPDEST
    PUSH2 0x2000 (8192)  // v30.i1 = lt v15 8192.i256;
    DUP2
    LT
    PUSH1 0x1 (1)  // v31.i256 = zext v30 i256;
    AND
    ISZERO  // v32.i1 = is_zero v31;
    PUSH1 block9  // br v19 block5 block9;
    JUMPI
  block5:
    POP  // jump block6;
    PUSH2 0x2000 (8192)
    PUSH1 block6
    JUMP
  block6:
    JUMPDEST
    DUP1  // v22.i256 = add v0 v20;
    SWAP2
    ADD
    PUSH1 0x40 (64)  // mstore 64.i256 v22 i256;
    MSTORE
    SWAP1  // return v20;
    JUMP
  block7:
    JUMPDEST
    POP  // jump block2;
  block8:
    JUMPDEST
  block9:
    JUMPDEST

// func private %runtime_selector__Evm_hef0af3106e109414_Sol_hfd482bb803ad8c5f__e4e3f8d20b3805a2() -> i256
runtime_selector__Evm_hef0af3106e109414_Sol_hfd482bb803ad8c5f__e4e3f8d20b3805a2:
  block0:
    JUMPDEST
    CALLDATASIZE  // v9.i256 = evm_calldata_size;
    PUSH1 0x4 (4)  // v17.i1 = lt v9 4.i256;
    SWAP1
    LT
    PUSH1 0x1 (1)  // v18.i256 = zext v17 i256;
    AND
    ISZERO  // v19.i1 = is_zero v18;
    PUSH1 block2  // br v6 block1 block2;
    JUMPI
  block1:
    PUSH0  // evm_revert 0.i256 0.i256;
    PUSH0
    REVERT
  block2:
    JUMPDEST
    PUSH0  // v12.i256 = evm_calldata_load 0.i256;
    CALLDATALOAD
    PUSH1 0xe0 (224)  // v14.i256 = shr 224.i256 v12;
    SHR
    SWAP1  // return v14;
    JUMP

// func private %return_value__Evm_hef0af3106e109414_Sol_hfd482bb803ad8c5f_u256__c4b26908c66ef75f(v0.i256)
return_value__Evm_hef0af3106e109414_Sol_hfd482bb803ad8c5f_u256__c4b26908c66ef75f:
  block0:
    JUMPDEST
    PUSH1 `pc + (3)`  // v2.i256 = call %solencoder_h1b9228b90dad6928_new;
    PUSH1 FuncRef(48)
    JUMP
    JUMPDEST
    DUP1  // call %solencoder_h1b9228b90dad6928_ensure_init v2 32.i256;
    PUSH1 0x20 (32)
    PUSH1 `pc + (4)`
    SWAP2
    PUSH1 FuncRef(60)
    JUMP
    JUMPDEST
    DUP1  // v19.*@__fe_SolEncoder_3 = int_to_ptr v2 *@__fe_SolEncoder_3;
    PUSH1 0x20 (32)  // v20.*i256 = gep v19 0.i256 1.i256;
    ADD
    MLOAD  // v22.i256 = mload v21 i256;
    SWAP2  // mstore v22 v0 i256;
    DUP3
    MSTORE
    SWAP1  // v23.i256 = add 32.i256 v22;
    PUSH1 0x20 (32)
    ADD
    DUP2  // v24.*@__fe_SolEncoder_3 = int_to_ptr v2 *@__fe_SolEncoder_3;
    PUSH1 0x20 (32)  // v25.*i256 = gep v24 0.i256 1.i256;
    ADD
    MSTORE  // mstore v26 v23 i256;
    PUSH1 `pc + (4)`  // v5.i256 = call %solencoder_h1b9228b90dad6928_abiencoder_hffd58d20d4321024_finish v2;
    SWAP1
    PUSH1 FuncRef(46)
    JUMP
    JUMPDEST
    DUP1  // v6.*@__fe_tuple_4 = int_to_ptr v5 *@__fe_tuple_4;
    MLOAD  // v9.i256 = mload v8 i256;
    SWAP1  // v10.*@__fe_tuple_4 = int_to_ptr v5 *@__fe_tuple_4;
    PUSH1 0x20 (32)  // v12.*i256 = gep v10 0.i256 1.i256;
    ADD
    MLOAD  // v14.i256 = mload v13 i256;
    SWAP1  // evm_return v9 v14;
    RETURN

// func private %decode_returndata__u256__3271ca15373d4483(v0.i256, v1.i256) -> i256
decode_returndata__u256__3271ca15373d4483:
  block0:
    JUMPDEST
    PUSH1 0x40 (64)  // v24.i256 = mload 64.i32 i256;
    MLOAD
    PUSH1 0x20 (32)  // v20.i1 = lt v1 32.i256;
    DUP4
    LT
    PUSH1 0x1 (1)  // v21.i256 = zext v20 i256;
    AND
    ISZERO  // v22.i1 = is_zero v21;
    PUSH1 block2  // br v6 block1 block2;
    JUMPI
  block1:
    POP  // evm_revert 0.i256 0.i256;
    POP
    POP
    PUSH0
    PUSH0
    REVERT
  block2:
    JUMPDEST
    PUSH1 0x40 (64)  // v8.*i8 = evm_malloc 64.i256;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP1  // v11.*@__fe_MemoryBytes_2 = int_to_ptr v9 *@__fe_MemoryBytes_2;
    SWAP1  // mstore v13 v0 i256;
    SWAP3
    SWAP1
    MSTORE
    DUP2  // v15.*@__fe_MemoryBytes_2 = int_to_ptr v9 *@__fe_MemoryBytes_2;
    PUSH1 0x20 (32)  // v17.*i256 = gep v15 0.i256 1.i256;
    ADD
    SWAP1  // mstore v18 v1 i256;
    SWAP3
    SWAP1
    MSTORE
    PUSH1 `pc + (4)`  // v19.i256 = call %soldecoder_i__ha12a03fcb5ba844b_new__MemoryBytes_h1e381015a9b0111b__59e0d528d54cca1b v9;
    SWAP1
    PUSH1 FuncRef(35)
    JUMP
    JUMPDEST
    PUSH1 `pc + (4)`  // v20.i256 = call %soldecoder_i__ha12a03fcb5ba844b_abidecoder_h638151350e80a086_read_word__MemoryBytes_h1e381015a9b0111b__59e0d528d54cca1b v19;
    SWAP1
    PUSH1 FuncRef(62)
    JUMP
    JUMPDEST
    SWAP1  // mstore 64.i32 v24 i256;
    PUSH1 0x40 (64)
    MSTORE
    SWAP1  // return v20;
    JUMP

// func public %soldecoder_i__ha12a03fcb5ba844b_new__MemoryBytes_h1e381015a9b0111b__59e0d528d54cca1b(v0.i256) -> i256
soldecoder_i__ha12a03fcb5ba844b_new__MemoryBytes_h1e381015a9b0111b__59e0d528d54cca1b:
  block0:
    JUMPDEST
    PUSH1 0x60 (96)  // v32.*i8 = evm_malloc 96.i256;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP2  // v34.*@__fe_MemoryBytes_2 = int_to_ptr v0 *@__fe_MemoryBytes_2;
    MLOAD  // v37.i256 = mload v36 i256;
    DUP2  // v38.*@__fe_Cursor_5 = int_to_ptr v33 *@__fe_Cursor_5;
    MSTORE  // mstore v40 v37 i256;
    SWAP1  // v41.*@__fe_MemoryBytes_2 = int_to_ptr v0 *@__fe_MemoryBytes_2;
    PUSH1 0x20 (32)  // v42.*i256 = gep v41 0.i256 1.i256;
    ADD
    MLOAD  // v44.i256 = mload v43 i256;
    DUP2  // v45.*@__fe_Cursor_5 = int_to_ptr v33 *@__fe_Cursor_5;
    PUSH1 0x20 (32)  // v46.*i256 = gep v45 0.i256 0.i256 1.i256;
    ADD
    MSTORE  // mstore v47 v44 i256;
    DUP1  // v48.*@__fe_Cursor_5 = int_to_ptr v33 *@__fe_Cursor_5;
    PUSH1 0x40 (64)  // v49.*i256 = gep v48 0.i256 1.i256;
    ADD
    PUSH0  // mstore v50 0.i256 i256;
    SWAP1
    MSTORE
    PUSH1 0x80 (128)  // v4.*i8 = evm_malloc 128.i256;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP2  // v6.*@__fe_Cursor_5 = int_to_ptr v33 *@__fe_Cursor_5;
    MLOAD  // v9.i256 = mload v8 i256;
    DUP2  // v10.*@__fe_SolDecoder_6 = int_to_ptr v5 *@__fe_SolDecoder_6;
    MSTORE  // mstore v12 v9 i256;
    DUP2  // v13.*@__fe_Cursor_5 = int_to_ptr v33 *@__fe_Cursor_5;
    PUSH1 0x20 (32)  // v15.*i256 = gep v13 0.i256 0.i256 1.i256;
    ADD
    MLOAD  // v17.i256 = mload v16 i256;
    DUP2  // v18.*@__fe_SolDecoder_6 = int_to_ptr v5 *@__fe_SolDecoder_6;
    PUSH1 0x20 (32)  // v19.*i256 = gep v18 0.i256 0.i256 0.i256 1.i256;
    ADD
    MSTORE  // mstore v20 v17 i256;
    SWAP1  // v21.*@__fe_Cursor_5 = int_to_ptr v33 *@__fe_Cursor_5;
    PUSH1 0x40 (64)  // v22.*i256 = gep v21 0.i256 1.i256;
    ADD
    MLOAD  // v24.i256 = mload v23 i256;
    DUP2  // v25.*@__fe_SolDecoder_6 = int_to_ptr v5 *@__fe_SolDecoder_6;
    PUSH1 0x40 (64)  // v26.*i256 = gep v25 0.i256 0.i256 1.i256;
    ADD
    MSTORE  // mstore v27 v24 i256;
    DUP1  // v28.*@__fe_SolDecoder_6 = int_to_ptr v5 *@__fe_SolDecoder_6;
    PUSH1 0x60 (96)  // v29.*i256 = gep v28 0.i256 1.i256;
    ADD
    PUSH0  // mstore v30 0.i256 i256;
    SWAP1
    MSTORE
    SWAP1  // return v5;
    JUMP

// func private %u256_h3271ca15373d4483_encode_hab7243eccf2714fb_encode__Sol_hfd482bb803ad8c5f_SolEncoder_h1b9228b90dad6928__1a070c3866d16383(v0.i256, v1.i256)
u256_h3271ca15373d4483_encode_hab7243eccf2714fb_encode__Sol_hfd482bb803ad8c5f_SolEncoder_h1b9228b90dad6928__1a070c3866d16383:
  block0:
    JUMPDEST
    DUP2  // v5.*@__fe_SolEncoder_3 = int_to_ptr v1 *@__fe_SolEncoder_3;
    PUSH1 0x20 (32)  // v6.*i256 = gep v5 0.i256 1.i256;
    ADD
    MLOAD  // v8.i256 = mload v7 i256;
    SWAP1  // mstore v8 v0 i256;
    DUP2
    MSTORE
    PUSH1 0x20 (32)  // v9.i256 = add 32.i256 v8;
    ADD
    SWAP1  // v10.*@__fe_SolEncoder_3 = int_to_ptr v1 *@__fe_SolEncoder_3;
    PUSH1 0x20 (32)  // v11.*i256 = gep v10 0.i256 1.i256;
    ADD
    MSTORE  // mstore v12 v9 i256;
    JUMP  // return;

// func private %solencoder_h1b9228b90dad6928_abiencoder_hffd58d20d4321024_finish(v0.i256) -> i256
solencoder_h1b9228b90dad6928_abiencoder_hffd58d20d4321024_finish:
  block0:
    JUMPDEST
    DUP1  // v2.*@__fe_SolEncoder_3 = int_to_ptr v0 *@__fe_SolEncoder_3;
    MLOAD  // v5.i256 = mload v4 i256;
    SWAP1  // v6.*@__fe_SolEncoder_3 = int_to_ptr v0 *@__fe_SolEncoder_3;
    PUSH1 0x40 (64)  // v8.*i256 = gep v6 0.i256 2.i256;
    ADD
    MLOAD  // v10.i256 = mload v9 i256;
    PUSH1 0x40 (64)  // v12.*i8 = evm_malloc 64.i256;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP1  // v14.*@__fe_tuple_4 = int_to_ptr v13 *@__fe_tuple_4;
    DUP4  // mstore v16 v5 i256;
    SWAP1
    MSTORE
    SWAP2  // v17.i256 = sub v10 v5;
    SWAP1
    SUB
    DUP2  // v18.*@__fe_tuple_4 = int_to_ptr v13 *@__fe_tuple_4;
    PUSH1 0x20 (32)  // v20.*i256 = gep v18 0.i256 1.i256;
    ADD
    MSTORE  // mstore v21 v17 i256;
    SWAP1  // return v13;
    JUMP

// func public %solencoder_h1b9228b90dad6928_new() -> i256
solencoder_h1b9228b90dad6928_new:
  block0:
    JUMPDEST
    PUSH1 0x60 (96)  // v2.*i8 = evm_malloc 96.i256;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP1  // v4.*@__fe_SolEncoder_3 = int_to_ptr v3 *@__fe_SolEncoder_3;
    PUSH0  // mstore v6 0.i256 i256;
    SWAP1
    MSTORE
    DUP1  // v7.*@__fe_SolEncoder_3 = int_to_ptr v3 *@__fe_SolEncoder_3;
    PUSH1 0x20 (32)  // v9.*i256 = gep v7 0.i256 1.i256;
    ADD
    PUSH0  // mstore v10 0.i256 i256;
    SWAP1
    MSTORE
    DUP1  // v11.*@__fe_SolEncoder_3 = int_to_ptr v3 *@__fe_SolEncoder_3;
    PUSH1 0x40 (64)  // v13.*i256 = gep v11 0.i256 2.i256;
    ADD
    PUSH0  // mstore v14 0.i256 i256;
    SWAP1
    MSTORE
    SWAP1  // return v3;
    JUMP

// func public %cursor_i__h140a998c67d6d59c_new__MemoryBytes_h1e381015a9b0111b__59e0d528d54cca1b(v0.i256) -> i256
cursor_i__h140a998c67d6d59c_new__MemoryBytes_h1e381015a9b0111b__59e0d528d54cca1b:
  block0:
    JUMPDEST
    PUSH1 0x60 (96)  // v3.*i8 = evm_malloc 96.i256;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP2  // v5.*@__fe_MemoryBytes_2 = int_to_ptr v0 *@__fe_MemoryBytes_2;
    MLOAD  // v8.i256 = mload v7 i256;
    DUP2  // v9.*@__fe_Cursor_5 = int_to_ptr v4 *@__fe_Cursor_5;
    MSTORE  // mstore v11 v8 i256;
    SWAP1  // v12.*@__fe_MemoryBytes_2 = int_to_ptr v0 *@__fe_MemoryBytes_2;
    PUSH1 0x20 (32)  // v14.*i256 = gep v12 0.i256 1.i256;
    ADD
    MLOAD  // v16.i256 = mload v15 i256;
    DUP2  // v17.*@__fe_Cursor_5 = int_to_ptr v4 *@__fe_Cursor_5;
    PUSH1 0x20 (32)  // v18.*i256 = gep v17 0.i256 0.i256 1.i256;
    ADD
    MSTORE  // mstore v19 v16 i256;
    DUP1  // v20.*@__fe_Cursor_5 = int_to_ptr v4 *@__fe_Cursor_5;
    PUSH1 0x40 (64)  // v21.*i256 = gep v20 0.i256 1.i256;
    ADD
    PUSH0  // mstore v22 0.i256 i256;
    SWAP1
    MSTORE
    SWAP1  // return v4;
    JUMP

// func public %soldecoder_i__ha12a03fcb5ba844b_with_base__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563(v0.i256, v1.i256) -> i256
soldecoder_i__ha12a03fcb5ba844b_with_base__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563:
  block0:
    JUMPDEST
    PUSH1 0x40 (64)  // v27.*i8 = evm_malloc 64.i256;
    POP
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1  // v29.*@__fe_Cursor_8 = int_to_ptr v28 *@__fe_Cursor_8;
    SWAP1  // mstore v31 v0 i256;
    SWAP2
    SWAP1
    MSTORE
    DUP1  // v32.*@__fe_Cursor_8 = int_to_ptr v28 *@__fe_Cursor_8;
    PUSH1 0x20 (32)  // v33.*i256 = gep v32 0.i256 1.i256;
    ADD
    PUSH0  // mstore v34 0.i256 i256;
    SWAP1
    MSTORE
    MLOAD  // v38.i256 = mload v37 i256;
    PUSH1 0x40 (64)  // v39.*i8 = evm_malloc 64.i256;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP1  // v41.*@__fe_Cursor_8 = int_to_ptr v40 *@__fe_Cursor_8;
    SWAP1  // mstore v43 v38 i256;
    SWAP2
    SWAP1
    MSTORE
    DUP1  // v44.*@__fe_Cursor_8 = int_to_ptr v40 *@__fe_Cursor_8;
    PUSH1 0x20 (32)  // v45.*i256 = gep v44 0.i256 1.i256;
    ADD
    DUP3  // mstore v46 v1 i256;
    SWAP1
    MSTORE
    PUSH1 0x60 (96)  // v6.*i8 = evm_malloc 96.i256;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP2  // v8.*@__fe_Cursor_8 = int_to_ptr v40 *@__fe_Cursor_8;
    MLOAD  // v11.i256 = mload v10 i256;
    DUP2  // v12.*@__fe_SolDecoder_9 = int_to_ptr v7 *@__fe_SolDecoder_9;
    MSTORE  // mstore v14 v11 i256;
    SWAP1  // v15.*@__fe_Cursor_8 = int_to_ptr v40 *@__fe_Cursor_8;
    PUSH1 0x20 (32)  // v17.*i256 = gep v15 0.i256 1.i256;
    ADD
    MLOAD  // v19.i256 = mload v18 i256;
    DUP2  // v20.*@__fe_SolDecoder_9 = int_to_ptr v7 *@__fe_SolDecoder_9;
    PUSH1 0x20 (32)  // v21.*i256 = gep v20 0.i256 0.i256 1.i256;
    ADD
    MSTORE  // mstore v22 v19 i256;
    DUP1  // v23.*@__fe_SolDecoder_9 = int_to_ptr v7 *@__fe_SolDecoder_9;
    PUSH1 0x40 (64)  // v24.*i256 = gep v23 0.i256 1.i256;
    ADD
    SWAP1  // mstore v25 v1 i256;
    SWAP2
    SWAP1
    MSTORE
    SWAP1  // return v7;
    JUMP

// func private %soldecoder_i__ha12a03fcb5ba844b_abidecoder_h638151350e80a086_read_word__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563(v0.i256) -> i256
soldecoder_i__ha12a03fcb5ba844b_abidecoder_h638151350e80a086_read_word__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563:
  block0:
    JUMPDEST
    DUP1  // v2.*@__fe_SolDecoder_9 = int_to_ptr v0 *@__fe_SolDecoder_9;
    MLOAD  // v8.i256 = mload v7 i256;
    CALLDATASIZE  // v54.i256 = evm_calldata_size;
    DUP3  // v10.*@__fe_SolDecoder_9 = int_to_ptr v0 *@__fe_SolDecoder_9;
    PUSH1 0x20 (32)  // v15.*i256 = gep v13 0.i256 1.i256;
    ADD
    MLOAD  // v17.i256 = mload v16 i256;
    DUP1  // v19.i256 = add 32.i256 v17;
    PUSH1 0x20 (32)
    ADD
    DUP5  // v20.*@__fe_SolDecoder_9 = int_to_ptr v0 *@__fe_SolDecoder_9;
    PUSH1 0x20 (32)  // v24.*i256 = gep v23 0.i256 1.i256;
    ADD
    MLOAD  // v26.i256 = mload v25 i256;
    SWAP2  // v72.i256 = add 32.i256 v17;
    PUSH1 0x20 (32)
    ADD
    SWAP4  // v73.i256 = sub v54 v8;
    SWAP1
    SWAP3
    SUB
    DUP4  // v74.i1 = gt v72 v73;
    GT
    PUSH1 0x1 (1)  // v75.i256 = zext v74 i256;
    AND
    SWAP3  // v76.i1 = lt v72 v26;
    LT
    PUSH1 0x1 (1)  // v77.i256 = zext v76 i256;
    AND
    SWAP1  // v78.i256 = or v75 v77;
    SWAP2
    OR
    PUSH0  // v32.i1 = ne 0.i256 v78;
    EQ
    PUSH1 block2  // br v32 block1 block2;
    JUMPI
  block1:
    POP  // evm_revert 0.i256 0.i256;
    POP
    PUSH0
    PUSH0
    REVERT
  block2:
    JUMPDEST
    DUP2  // v34.*@__fe_SolDecoder_9 = int_to_ptr v0 *@__fe_SolDecoder_9;
    MLOAD  // v40.i256 = mload v39 i256;
    DUP3  // v41.*@__fe_SolDecoder_9 = int_to_ptr v0 *@__fe_SolDecoder_9;
    PUSH1 0x20 (32)  // v45.*i256 = gep v44 0.i256 1.i256;
    ADD
    MLOAD  // v47.i256 = mload v46 i256;
    ADD  // v56.i256 = add v40 v47;
    CALLDATALOAD  // v57.i256 = evm_calldata_load v56;
    SWAP1  // v50.*@__fe_SolDecoder_9 = int_to_ptr v0 *@__fe_SolDecoder_9;
    SWAP2
    PUSH1 0x20 (32)  // v54.*i256 = gep v53 0.i256 1.i256;
    ADD
    SWAP1  // mstore v55 v19 i256;
    SWAP2
    SWAP1
    MSTORE
    SWAP1  // return v57;
    JUMP

// func private %solencoder_h1b9228b90dad6928_ensure_init(v0.i256, v1.i256)
solencoder_h1b9228b90dad6928_ensure_init:
  block0:
    JUMPDEST
    DUP1  // v3.*@__fe_SolEncoder_3 = int_to_ptr v0 *@__fe_SolEncoder_3;
    MLOAD  // v6.i256 = mload v5 i256;
    ISZERO  // v25.i1 = is_zero v6;
    PUSH1 0x1 (1)  // v26.i256 = zext v25 i256;
    AND
    ISZERO  // v27.i1 = is_zero v26;
    PUSH1 block3  // br v9 block1 block3;
    JUMPI
  block1:
    DUP2  // v11.*i8 = evm_malloc v1;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP2  // v14.*@__fe_SolEncoder_3 = int_to_ptr v0 *@__fe_SolEncoder_3;
    DUP2  // mstore v16 v12 i256;
    SWAP1
    MSTORE
    DUP2  // v17.*@__fe_SolEncoder_3 = int_to_ptr v0 *@__fe_SolEncoder_3;
    PUSH1 0x20 (32)  // v19.*i256 = gep v17 0.i256 1.i256;
    ADD
    DUP2  // mstore v20 v12 i256;
    SWAP1
    MSTORE
    SWAP1  // v21.i256 = add v1 v12;
    SWAP2
    ADD
    SWAP1  // v22.*@__fe_SolEncoder_3 = int_to_ptr v0 *@__fe_SolEncoder_3;
    PUSH1 0x40 (64)  // v24.*i256 = gep v22 0.i256 2.i256;
    ADD
    MSTORE  // mstore v25 v21 i256;
    PUSH1 block2  // jump block2;
    JUMP
  block2:
    JUMPDEST
    JUMP  // return;
  block3:
    JUMPDEST
    POP  // jump block2;
    POP

// func private %soldecoder_i__ha12a03fcb5ba844b_abidecoder_h638151350e80a086_read_word__MemoryBytes_h1e381015a9b0111b__59e0d528d54cca1b(v0.i256) -> i256
soldecoder_i__ha12a03fcb5ba844b_abidecoder_h638151350e80a086_read_word__MemoryBytes_h1e381015a9b0111b__59e0d528d54cca1b:
  block0:
    JUMPDEST
    DUP1  // v2.*@__fe_SolDecoder_6 = int_to_ptr v0 *@__fe_SolDecoder_6;
    PUSH1 0x20 (32)  // v53.*i256 = gep v52 0.i256 1.i256;
    ADD
    MLOAD  // v55.i256 = mload v54 i256;
    DUP2  // v9.*@__fe_SolDecoder_6 = int_to_ptr v0 *@__fe_SolDecoder_6;
    PUSH1 0x40 (64)  // v14.*i256 = gep v12 0.i256 1.i256;
    ADD
    MLOAD  // v16.i256 = mload v15 i256;
    DUP1  // v18.i256 = add 32.i256 v16;
    PUSH1 0x20 (32)
    ADD
    DUP4  // v19.*@__fe_SolDecoder_6 = int_to_ptr v0 *@__fe_SolDecoder_6;
    PUSH1 0x40 (64)  // v23.*i256 = gep v22 0.i256 1.i256;
    ADD
    MLOAD  // v25.i256 = mload v24 i256;
    SWAP2  // v73.i256 = add 32.i256 v16;
    PUSH1 0x20 (32)
    ADD
    SWAP3  // v74.i1 = gt v73 v55;
    DUP4
    GT
    PUSH1 0x1 (1)  // v75.i256 = zext v74 i256;
    AND
    SWAP2  // v76.i1 = lt v73 v25;
    SWAP1
    SWAP3
    LT
    PUSH1 0x1 (1)  // v77.i256 = zext v76 i256;
    AND
    OR  // v78.i256 = or v75 v77;
    PUSH0  // v31.i1 = ne 0.i256 v78;
    EQ
    PUSH1 block2  // br v31 block1 block2;
    JUMPI
  block1:
    POP  // evm_revert 0.i256 0.i256;
    POP
    PUSH0
    PUSH0
    REVERT
  block2:
    JUMPDEST
    DUP2  // v33.*@__fe_SolDecoder_6 = int_to_ptr v0 *@__fe_SolDecoder_6;
    PUSH1 0x40 (64)  // v37.*i256 = gep v36 0.i256 1.i256;
    ADD
    MLOAD  // v39.i256 = mload v38 i256;
    DUP3  // v40.*@__fe_SolDecoder_6 = int_to_ptr v0 *@__fe_SolDecoder_6;
    MLOAD  // v59.i256 = mload v58 i256;
    ADD  // v60.i256 = add v39 v59;
    MLOAD  // v61.i256 = mload v60 i256;
    SWAP1  // v48.*@__fe_SolDecoder_6 = int_to_ptr v0 *@__fe_SolDecoder_6;
    SWAP2
    PUSH1 0x40 (64)  // v52.*i256 = gep v51 0.i256 1.i256;
    ADD
    SWAP1  // mstore v53 v18 i256;
    SWAP2
    SWAP1
    MSTORE
    SWAP1  // return v61;
    JUMP

// func public %cursor_i__h140a998c67d6d59c_new__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563(v0.i256) -> i256
cursor_i__h140a998c67d6d59c_new__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563:
  block0:
    JUMPDEST
    PUSH1 0x40 (64)  // v3.*i8 = evm_malloc 64.i256;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP1  // v5.*@__fe_Cursor_8 = int_to_ptr v4 *@__fe_Cursor_8;
    SWAP1  // mstore v7 v0 i256;
    SWAP2
    SWAP1
    MSTORE
    DUP1  // v8.*@__fe_Cursor_8 = int_to_ptr v4 *@__fe_Cursor_8;
    PUSH1 0x20 (32)  // v10.*i256 = gep v8 0.i256 1.i256;
    ADD
    PUSH0  // mstore v11 0.i256 i256;
    SWAP1
    MSTORE
    SWAP1  // return v4;
    JUMP

// func public %cursor_i__h140a998c67d6d59c_fork__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563(v0.i256, v1.i256) -> i256
cursor_i__h140a998c67d6d59c_fork__CallData_hf71d505b6ff5dc81__e6d5f05c3478f563:
  block0:
    JUMPDEST
    MLOAD  // v6.i256 = mload v5 i256;
    PUSH1 0x40 (64)  // v8.*i8 = evm_malloc 64.i256;
    PUSH1 0x1f (31)
    ADD
    PUSH1 0x1f (31)
    NOT
    AND
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    DUP1
    SWAP2
    ADD
    PUSH1 0x40 (64)
    MSTORE
    DUP1  // v10.*@__fe_Cursor_8 = int_to_ptr v9 *@__fe_Cursor_8;
    SWAP1  // mstore v12 v6 i256;
    SWAP2
    SWAP1
    MSTORE
    DUP1  // v13.*@__fe_Cursor_8 = int_to_ptr v9 *@__fe_Cursor_8;
    PUSH1 0x20 (32)  // v15.*i256 = gep v13 0.i256 1.i256;
    ADD
    SWAP1  // mstore v16 v1 i256;
    SWAP2
    SWAP1
    MSTORE
    SWAP1  // return v9;
    JUMP



--------------- BYTECODE ---------------

// section runtime
0x5b5f5f600a916101ff565b8015156001166018906101f0565b6040601f01601f1916604051608051818111603257506035565b90505b60c0818111604257506045565b90505b809101604052805f905280602001600a905281905f620186a06066936105fe565b600a146001166074906101f0565b6040601f01601f1916604051608051818111608e57506091565b90505b60c0818111609e575060a1565b90505b8091016040528060019052806020016005905281905f620186a060c3936105fe565b60051460011660d1906101f0565b6040601f01601f191660405160805181811160eb575060ee565b90505b60c081811160fb575060fe565b90505b809101604052805f9052806020016003905281905f620186a0610120936107a1565b1560011661012d906101f0565b805f5f620186a061013d936102bf565b60071460011661014c906101f0565b8060015f620186a061015d936102bf565b60081460011661016c906101f0565b6040601f01601f1916604051608051818111610188575061018b565b90505b60c081811161019a575061019d565b90505b8091016040528060019052806020016014905281905f620186a06101c0936107a1565b6001146001166101cf906101f0565b5f620186a06101dd926106de565b600f146001166101ec906101f0565b5f5ff35b15600116156101fd575f5ffd5b565b61058361088181601f01601f19166040516080518181116102205750610223565b90505b60c08181116102325750610235565b90505b8091016040528091839139808201606050604051608051818111610259575061025c565b90505b60c081811161026b575061026e565b90505b8082905280602001829052604001529091f58015600116156102bc57503d80506040516080518181116102a157506102a4565b90505b60c08181116102b357506102b6565b90505b815f823efd5b90565b6040516040516102cd6105a0565b8060246102d991610542565b80517f6c65aae500000000000000000000000000000000000000000000000000000000815260040181602001529586610311916105ec565b8561031b906104f5565b805190602001515f5f9091909192888789f13d80601f01601f1916604051608051818111610349575061034c565b90505b60c081811161035b575061035e565b90505b809101604052815f823e9091156001161561037557fd5b9061037f9161038f565b9060405290604052935050505090565b60405160405160208410600116156103a957505050505f5ffd5b6040601f01601f19166040516080518181116103c557506103c8565b90505b60c08181116103d757506103da565b90505b80910160405280909390528260200190939052906103f790610450565b6104009061040a565b9160405260405290565b806020015181604001518060200183604001519160200192831160011691909210600116175f1461043b5750505f5ffd5b81604001518251015190916040019091905290565b6060601f01601f191660405160805181811161046c575061046f565b90505b60c081811161047e5750610481565b90505b8091016040528151815290602001518160200152806040015f90526080601f01601f19166040516080518181116104b857506104bb565b90505b60c08181116104ca57506104cd565b90505b809101604052815181528160200151816020015290604001518160400152806060015f905290565b805190604001516040601f01601f1916604051608051818111610518575061051b565b90505b60c081811161052a575061052d565b90505b80910160405280839052919003816020015290565b8051156001161561059b5781601f01601f1916604051608051818111610568575061056b565b90505b60c081811161057a575061057d565b90505b8091016040528181905281602001819052909101906040015261059e565b50505b565b6060601f01601f19166040516080518181116105bc57506105bf565b90505b60c08181116105ce57506105d1565b90505b809101604052805f9052806020015f9052806040015f905290565b81602001519081526020019060200152565b60405160405161060c6105a0565b80604461061891610542565b80517fab7ccc1c0000000000000000000000000000000000000000000000000000000081526004018160200152865187602001519082610657916105ec565b81610661916105ec565b61066a906104f5565b805190602001515f5f9091909192888789f13d80601f01601f1916604051608051818111610698575061069b565b90505b60c08181116106aa57506106ad565b90505b809101604052815f823e909115600116156106c457fd5b906106ce9161038f565b9060405290604052935050505090565b6040516040516106ec6105a0565b8060046106f891610542565b80517f3940e9ee000000000000000000000000000000000000000000000000000000008152600401816020015261072e906104f5565b805190602001515f5f9091909192888789f13d80601f01601f191660405160805181811161075c575061075f565b90505b60c081811161076e5750610771565b90505b809101604052815f823e9091156001161561078857fd5b906107929161038f565b90604052906040529250505090565b6040516040516107af6105a0565b8060446107bb91610542565b80517f0cf79e0a00000000000000000000000000000000000000000000000000000000815260040181602001528651876020015190826107fa916105ec565b81610804916105ec565b61080d906104f5565b805190602001515f5f9091909192888789f13d80601f01601f191660405160805181811161083b575061083e565b90505b60c081811161084d5750610850565b90505b809101604052815f823e9091156001161561086757fd5b906108719161038f565b9060405290604052935050505090565b61015961042a38818301811060011615601a575050505f5ffd5b8183018103601f01601f191660405160805181811160375750603a565b90505b60c081811160475750604a565b90505b80910160405282840183850183039082396040601f01601f1916604051608051818111607557506078565b90505b60c0818111608557506088565b90505b8091016040528090919052828401909103816020015260a59060b8565b505f5f555f6001555f60025580915f395ff35b6060601f01601f191660405160805181811160d2575060d5565b90505b60c081811160e2575060e5565b90505b8091016040528151815290602001518160200152806040015f90526080601f01601f191660405160805181811161011c575061011f565b90505b60c081811161012e5750610131565b90505b809101604052815181528160200151816020015290604001518160400152806060015f905290565b60076103ca565b604050604051608051818111601b5750601e565b90505b60c0818111602b5750602e565b90505b805f9052806020015f9052516040601f01601f1916604051608051818111605457506057565b90505b60c0818111606457506067565b90505b80910160405280909190528060200160049052606050604051608051818111608e57506091565b90505b60c0818111609e575060a1565b90505b815181529060200151816020015280604001600490528163ab7ccc1c141561011d5790508060ce906103e3565b9060d7906103e3565b60405060405160805181811160eb575060ee565b90505b60c081811160fb575060fe565b90505b809092905281602001525f610112916101d2565b61011b9061029b565bfe5b81630cf79e0a141561018957905080610135906103e3565b9061013f906103e3565b6040506040516080518181116101555750610158565b90505b60c0818111610167575061016a565b90505b809092905281602001525f61017e91610219565b6101879061029b565bfe5b81636c65aae514156101b55790506101a0906103e3565b5f6101aa91610284565b6101b39061029b565bfe5b50633940e9ee146101c4575f5ffd5b6002546101d09061029b565bfe5b805190602001519015600116600114156101fb5781548101825581600201540181600201555490565b81600101548101826001015581600201540181600201556001015490565b8051906020015190156001166001141561025757815481901060011615610241575050600190565b8154819003825581600101540190600101555f90565b81600101548190106001161561026e575050600190565b8160010154819003826001015581540190555f90565b1560011660011415610294575490565b6001015490565b6102a361037e565b8060206102af91610320565b80602001519182529060200181602001526102c9906102d3565b8051906020015190f35b805190604001516040601f01601f19166040516080518181116102f657506102f9565b90505b60c0818111610308575061030b565b90505b80910160405280839052919003816020015290565b805115600116156103795781601f01601f19166040516080518181116103465750610349565b90505b60c0818111610358575061035b565b90505b8091016040528181905281602001819052909101906040015261037c565b50505b565b6060601f01601f191660405160805181811161039a575061039d565b90505b60c08181116103ac57506103af565b90505b809101604052805f9052806020015f9052806040015f905290565b3660049010600116156103db575f5ffd5b5f3560e01c90565b80513682602001518060200184602001519160200193909203831160011692106001169091175f146104155750505f5ffd5b8151826020015101359091602001909190529056

// section coin_init
0x5b61015961042a38818301811060011615601a575050505f5ffd5b8183018103601f01601f191660405160805181811160375750603a565b90505b60c081811160475750604a565b90505b80910160405282840183850183039082396040601f01601f1916604051608051818111607557506078565b90505b60c0818111608557506088565b90505b8091016040528090919052828401909103816020015260a59060b8565b505f5f555f6001555f60025580915f395ff35b6060601f01601f191660405160805181811160d2575060d5565b90505b60c081811160e2575060e5565b90505b8091016040528151815290602001518160200152806040015f90526080601f01601f191660405160805181811161011c575061011f565b90505b60c081811161012e5750610131565b90505b809101604052815181528160200151816020015290604001518160400152806060015f905290565b60076103ca565b604050604051608051818111601b5750601e565b90505b60c0818111602b5750602e565b90505b805f9052806020015f9052516040601f01601f1916604051608051818111605457506057565b90505b60c0818111606457506067565b90505b80910160405280909190528060200160049052606050604051608051818111608e57506091565b90505b60c0818111609e575060a1565b90505b815181529060200151816020015280604001600490528163ab7ccc1c141561011d5790508060ce906103e3565b9060d7906103e3565b60405060405160805181811160eb575060ee565b90505b60c081811160fb575060fe565b90505b809092905281602001525f610112916101d2565b61011b9061029b565bfe5b81630cf79e0a141561018957905080610135906103e3565b9061013f906103e3565b6040506040516080518181116101555750610158565b90505b60c0818111610167575061016a565b90505b809092905281602001525f61017e91610219565b6101879061029b565bfe5b81636c65aae514156101b55790506101a0906103e3565b5f6101aa91610284565b6101b39061029b565bfe5b50633940e9ee146101c4575f5ffd5b6002546101d09061029b565bfe5b805190602001519015600116600114156101fb5781548101825581600201540181600201555490565b81600101548101826001015581600201540181600201556001015490565b8051906020015190156001166001141561025757815481901060011615610241575050600190565b8154819003825581600101540190600101555f90565b81600101548190106001161561026e575050600190565b8160010154819003826001015581540190555f90565b1560011660011415610294575490565b6001015490565b6102a361037e565b8060206102af91610320565b80602001519182529060200181602001526102c9906102d3565b8051906020015190f35b805190604001516040601f01601f19166040516080518181116102f657506102f9565b90505b60c0818111610308575061030b565b90505b80910160405280839052919003816020015290565b805115600116156103795781601f01601f19166040516080518181116103465750610349565b90505b60c0818111610358575061035b565b90505b8091016040528181905281602001819052909101906040015261037c565b50505b565b6060601f01601f191660405160805181811161039a575061039d565b90505b60c08181116103ac57506103af565b90505b809101604052805f9052806020015f9052806040015f905290565b3660049010600116156103db575f5ffd5b5f3560e01c90565b80513682602001518060200184602001519160200193909203831160011692106001169091175f146104155750505f5ffd5b8151826020015101359091602001909190529056

// section coin_runtime
0x5b60076103ca565b604050604051608051818111601b5750601e565b90505b60c0818111602b5750602e565b90505b805f9052806020015f9052516040601f01601f1916604051608051818111605457506057565b90505b60c0818111606457506067565b90505b80910160405280909190528060200160049052606050604051608051818111608e57506091565b90505b60c0818111609e575060a1565b90505b815181529060200151816020015280604001600490528163ab7ccc1c141561011d5790508060ce906103e3565b9060d7906103e3565b60405060405160805181811160eb575060ee565b90505b60c081811160fb575060fe565b90505b809092905281602001525f610112916101d2565b61011b9061029b565bfe5b81630cf79e0a141561018957905080610135906103e3565b9061013f906103e3565b6040506040516080518181116101555750610158565b90505b60c0818111610167575061016a565b90505b809092905281602001525f61017e91610219565b6101879061029b565bfe5b81636c65aae514156101b55790506101a0906103e3565b5f6101aa91610284565b6101b39061029b565bfe5b50633940e9ee146101c4575f5ffd5b6002546101d09061029b565bfe5b805190602001519015600116600114156101fb5781548101825581600201540181600201555490565b81600101548101826001015581600201540181600201556001015490565b8051906020015190156001166001141561025757815481901060011615610241575050600190565b8154819003825581600101540190600101555f90565b81600101548190106001161561026e575050600190565b8160010154819003826001015581540190555f90565b1560011660011415610294575490565b6001015490565b6102a361037e565b8060206102af91610320565b80602001519182529060200181602001526102c9906102d3565b8051906020015190f35b805190604001516040601f01601f19166040516080518181116102f657506102f9565b90505b60c0818111610308575061030b565b90505b80910160405280839052919003816020015290565b805115600116156103795781601f01601f19166040516080518181116103465750610349565b90505b60c0818111610358575061035b565b90505b8091016040528181905281602001819052909101906040015261037c565b50505b565b6060601f01601f191660405160805181811161039a575061039d565b90505b60c08181116103ac57506103af565b90505b809101604052805f9052806020015f9052806040015f905290565b3660049010600116156103db575f5ffd5b5f3560e01c90565b80513682602001518060200184602001519160200193909203831160011692106001169091175f146104155750505f5ffd5b8151826020015101359091602001909190529056
