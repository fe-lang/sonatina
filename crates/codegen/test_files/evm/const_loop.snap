---
source: crates/codegen/tests/evm.rs
expression: "String::from_utf8(v).unwrap()"
input_file: test_files/evm/const_loop.sntn
---
// func public %entry()
  block0 P=[] T=[]
    - stack=[]
      pre: [PUSH_CONT]
      call [] -> v0
    - stack=[v0], last_use=[v0]
      pre: [PUSH(0)]
      mstore [0, v0]
    - stack=[]
      pre: [PUSH(32), PUSH(0)]
      evm_return [0, 32]

// func public %const_loop() -> i8
  block1 P=[] T=[]
    - stack=[<RET>]
      exit(block2): [PUSH(1)]
      jump -> block2
  block2 P=[v0] T=[]
    - stack=[v0, <RET>]
      pre: [PUSH(10), DUP2]
      add [v0, 10] -> v1
    - stack=[v1, v0, <RET>], last_use=[v0]
      pre: [SWAP1, DUP2]
      gt [v1, v0] -> v2
    - stack=[v2, v1, <RET>]
      br [v2] -> [block3, block4]
  block3 P=[] T=[v1]
    inherited from block2: [v1, <RET>]
    - stack=[v1, <RET>]
      return [v1]
  block4 P=[] T=[v1]
    inherited from block2: [v1, <RET>]
    - stack=[v1, <RET>]
      jump -> block2

// func public %entry()
entry:
  block0:
    JUMPDEST
    PUSH1 `pc + (3)`  // v0.i8 = call %const_loop;
    PUSH1 FuncRef(1)
    JUMP
    JUMPDEST
    PUSH0  // mstore 0.i32 v0 i8;
    MSTORE
    PUSH1 0x20 (32)  // evm_return 0.i8 32.i8;
    PUSH0
    RETURN

// func public %const_loop() -> i8
const_loop:
  block1:
    JUMPDEST
    PUSH1 0x1 (1)  // jump block2;
  block2:
    JUMPDEST
    PUSH1 0xa (10)  // v2.i8 = add v1 10.i8;
    DUP2
    ADD
    SWAP1  // v3.i1 = gt v2 v1;
    DUP2
    GT
    ISZERO  // br v3 block3 block4;
    PUSH1 block4
    JUMPI
  block3:
    JUMPDEST
    SWAP1  // return v2;
    JUMP
  block4:
    JUMPDEST
    PUSH1 block2  // jump block2;
    JUMP



---------------

// func public %entry()
entry:
  block0:
    0    JUMPDEST
    1    PUSH1 6  // v0.i8 = call %const_loop;
    3    PUSH1 13 (FuncRef(1))
    5    JUMP
    6    JUMPDEST
    7    PUSH0  // mstore 0.i32 v0 i8;
    8    MSTORE
    9    PUSH1 0x20 (32)  // evm_return 0.i8 32.i8;
   11    PUSH0
   12    RETURN
// func public %const_loop() -> i8
const_loop:
  block1:
   13    JUMPDEST
   14    PUSH1 0x1 (1)  // jump block2;
  block2:
   16    JUMPDEST
   17    PUSH1 0xa (10)  // v2.i8 = add v1 10.i8;
   19    DUP2
   20    ADD
   21    SWAP1  // v3.i1 = gt v2 v1;
   22    DUP2
   23    GT
   24    ISZERO  // br v3 block3 block4;
   25    PUSH1 31 (block4)
   27    JUMPI
  block3:
   28    JUMPDEST
   29    SWAP1  // return v2;
   30    JUMP
  block4:
   31    JUMPDEST
   32    PUSH1 16 (block2)  // jump block2;
   34    JUMP

0x5b6006600d565b5f5260205ff35b60015b600a810190811115601f575b90565b601056

Success { reason: Return, gas_used: 21136, gas_refunded: 0, logs: [], output: Call(0x000000000000000000000000000000000000000000000000000000000000000b) }

    pc  opcode            input (stack grows to the right)
     0  5b  JUMPDEST      []
     1  60  PUSH1         0x06  []
     3  60  PUSH1         0x0d  [0x6]
     5  56  JUMP          [0x6, 0xd]
    13  5b  JUMPDEST      [0x6]
    14  60  PUSH1         0x01  [0x6]
    16  5b  JUMPDEST      [0x6, 0x1]
    17  60  PUSH1         0x0a  [0x6, 0x1]
    19  81  DUP2          [0x6, 0x1, 0xa]
    20  01  ADD           [0x6, 0x1, 0xa, 0x1]
    21  90  SWAP1         [0x6, 0x1, 0xb]
    22  81  DUP2          [0x6, 0xb, 0x1]
    23  11  GT            [0x6, 0xb, 0x1, 0xb]
    24  15  ISZERO        [0x6, 0xb, 0x1]
    25  60  PUSH1         0x1f  [0x6, 0xb, 0x0]
    27  57  JUMPI         [0x6, 0xb, 0x0, 0x1f]
    28  5b  JUMPDEST      [0x6, 0xb]
    29  90  SWAP1         [0x6, 0xb]
    30  56  JUMP          [0xb, 0x6]
     6  5b  JUMPDEST      [0xb]
     7  5f  PUSH0         [0xb]
     8  52  MSTORE        [0xb, 0x0]
     9  60  PUSH1         0x20  []
    11  5f  PUSH0         [0x20]
    12  f3  RETURN        [0x20, 0x0]
