---
source: crates/codegen/tests/evm.rs
expression: "String::from_utf8(v).unwrap()"
input_file: test_files/evm/malloc_path_sensitive.sntn
---
// func public %big() -> i256
  block0 P=[] T=[]
    - stack=[<RET>]
      alloca [] -> v0
    - stack=[v0, <RET>], last_use=[v0]
      pre: [PUSH(0), PUSH(0), SWAP1, SWAP2]
      gep [v0, 0, 0] -> v1
    - stack=[v1, <RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 1 }), DUP2]
      mstore [v1, I256 { is_negative: false, abs: 1 }]
    - stack=[v1, <RET>], last_use=[v1]
      mload [v1] -> v2
    - stack=[v2, <RET>]
      return [v2]

// func public %small() -> i256
  block0 P=[] T=[]
    - stack=[<RET>]
      return: [PUSH(I256 { is_negative: false, abs: 2 })]
      return [I256 { is_negative: false, abs: 2 }]

// func public %dispatch(v0.i1) -> i256
  block0 P=[v0] T=[]
    - stack=[v0, <RET>]
      br [v0] -> [block1, block2]
  block1 P=[] T=[]
    inherited from block0: [<RET>]
    - stack=[<RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 32 })]
      evm_malloc [I256 { is_negative: false, abs: 32 }] -> v1
    - stack=[v1x, <RET>]
      cleanup: [POP]
      pre: [PUSH_CONT]
      call [] -> v2
    - stack=[v2, <RET>]
      return [v2]
  block2 P=[] T=[]
    inherited from block0: [<RET>]
    - stack=[<RET>]
      pre: [PUSH(I256 { is_negative: false, abs: 32 })]
      evm_malloc [I256 { is_negative: false, abs: 32 }] -> v3
    - stack=[v3x, <RET>]
      cleanup: [POP]
      pre: [PUSH_CONT]
      call [] -> v4
    - stack=[v4, <RET>]
      return [v4]

// func public %entry()
  block0 P=[] T=[]
    - stack=[]
      pre: [PUSH_CONT, PUSH(true)]
      call [true] -> v0
    - stack=[v0], last_use=[v0]
      pre: [PUSH(0)]
      mstore [0, v0]
    - stack=[]
      pre: [PUSH(32), PUSH(0)]
      evm_return [0, 32]

// func public %big() -> i256
big:
  block0:
    JUMPDEST
    PUSH1 0xc0 (192)  // v0.*@big = alloca @big;
    PUSH0  // v1.*i256 = gep v0 0.i8 0.i8;
    PUSH0
    SWAP1
    SWAP2
    SWAP1
    POP
    SWAP1
    POP
    PUSH1 0x1 (1)  // mstore v1 1.i256 i256;
    DUP2
    MSTORE
    MLOAD  // v2.i256 = mload v1 i256;
    SWAP1  // return v2;
    JUMP

// func public %small() -> i256
small:
  block0:
    JUMPDEST
    PUSH1 0x2 (2)  // return 2.i256;
    SWAP1
    JUMP

// func public %dispatch(v0.i1) -> i256
dispatch:
  block0:
    JUMPDEST
    ISZERO  // br v0 block1 block2;
    PUSH1 block2
    JUMPI
  block1:
    JUMPDEST
    PUSH1 0x20 (32)  // v1.*i8 = evm_malloc 32.i256;
    POP
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH2 0x1c0 (448)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    POP  // v2.i256 = call %big;
    PUSH1 `pc + (3)`
    PUSH1 FuncRef(0)
    JUMP
    JUMPDEST
    SWAP1  // return v2;
    JUMP
  block2:
    JUMPDEST
    PUSH1 0x20 (32)  // v3.*i8 = evm_malloc 32.i256;
    POP
    PUSH1 0x40 (64)
    MLOAD
    PUSH1 0x80 (128)
    MLOAD
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    PUSH1 0xc0 (192)
    DUP2
    DUP2
    GT
    PUSH1 `pc + (5)`
    JUMPI
    POP
    PUSH1 `pc + (5)`
    JUMP
    JUMPDEST
    SWAP1
    POP
    JUMPDEST
    POP  // v4.i256 = call %small;
    PUSH1 `pc + (3)`
    PUSH1 FuncRef(1)
    JUMP
    JUMPDEST
    SWAP1  // return v4;
    JUMP

// func public %entry()
entry:
  block0:
    JUMPDEST
    PUSH1 `pc + (6)`  // v0.i256 = call %dispatch 1.i1;
    PUSH1 0x1 (1)
    PUSH0
    SIGNEXTEND
    PUSH1 FuncRef(2)
    JUMP
    JUMPDEST
    PUSH0  // mstore 0.i32 v0 i256;
    MSTORE
    PUSH1 0x20 (32)  // evm_return 0.i8 32.i8;
    PUSH0
    RETURN



---------------

// section runtime
0x5b600a60015f0b6011565b5f5260205ff35b156048575b602050604051608051818111602a5750602d565b90505b6101c0818111603b5750603e565b90505b5060456079565b90565b602050604051608051818111605c5750605f565b90505b60c0818111606c5750606f565b90505b506076608b565b90565b60c05f5f909190509050600181525190565b60029056


Success { reason: Return, gas_used: 21291, gas_refunded: 0, logs: [], output: Call(0x0000000000000000000000000000000000000000000000000000000000000001) }

    pc  opcode            input (stack grows to the right)
     0  5b  JUMPDEST      []
     1  60  PUSH1         0x0a  []
     3  60  PUSH1         0x01  [0xa]
     5  5f  PUSH0         [0xa, 0x1]
     6  0b  SIGNEXTEND    [0xa, 0x1, 0x0]
     7  60  PUSH1         0x11  [0xa, 0x1]
     9  56  JUMP          [0xa, 0x1, 0x11]
    17  5b  JUMPDEST      [0xa, 0x1]
    18  15  ISZERO        [0xa, 0x1]
    19  60  PUSH1         0x48  [0xa, 0x0]
    21  57  JUMPI         [0xa, 0x0, 0x48]
    22  5b  JUMPDEST      [0xa]
    23  60  PUSH1         0x20  [0xa]
    25  50  POP           [0xa, 0x20]
    26  60  PUSH1         0x40  [0xa]
    28  51  MLOAD         [0xa, 0x40]
    29  60  PUSH1         0x80  [0xa, 0x0]
    31  51  MLOAD         [0xa, 0x0, 0x80]
    32  81  DUP2          [0xa, 0x0, 0x0]
    33  81  DUP2          [0xa, 0x0, 0x0, 0x0]
    34  11  GT            [0xa, 0x0, 0x0, 0x0, 0x0]
    35  60  PUSH1         0x2a  [0xa, 0x0, 0x0, 0x0]
    37  57  JUMPI         [0xa, 0x0, 0x0, 0x0, 0x2a]
    38  50  POP           [0xa, 0x0, 0x0]
    39  60  PUSH1         0x2d  [0xa, 0x0]
    41  56  JUMP          [0xa, 0x0, 0x2d]
    45  5b  JUMPDEST      [0xa, 0x0]
    46  61  PUSH2         0x01c0  [0xa, 0x0]
    49  81  DUP2          [0xa, 0x0, 0x1c0]
    50  81  DUP2          [0xa, 0x0, 0x1c0, 0x0]
    51  11  GT            [0xa, 0x0, 0x1c0, 0x0, 0x1c0]
    52  60  PUSH1         0x3b  [0xa, 0x0, 0x1c0, 0x1]
    54  57  JUMPI         [0xa, 0x0, 0x1c0, 0x1, 0x3b]
    59  5b  JUMPDEST      [0xa, 0x0, 0x1c0]
    60  90  SWAP1         [0xa, 0x0, 0x1c0]
    61  50  POP           [0xa, 0x1c0, 0x0]
    62  5b  JUMPDEST      [0xa, 0x1c0]
    63  50  POP           [0xa, 0x1c0]
    64  60  PUSH1         0x45  [0xa]
    66  60  PUSH1         0x79  [0xa, 0x45]
    68  56  JUMP          [0xa, 0x45, 0x79]
   121  5b  JUMPDEST      [0xa, 0x45]
   122  60  PUSH1         0xc0  [0xa, 0x45]
   124  5f  PUSH0         [0xa, 0x45, 0xc0]
   125  5f  PUSH0         [0xa, 0x45, 0xc0, 0x0]
   126  90  SWAP1         [0xa, 0x45, 0xc0, 0x0, 0x0]
   127  91  SWAP2         [0xa, 0x45, 0xc0, 0x0, 0x0]
   128  90  SWAP1         [0xa, 0x45, 0x0, 0x0, 0xc0]
   129  50  POP           [0xa, 0x45, 0x0, 0xc0, 0x0]
   130  90  SWAP1         [0xa, 0x45, 0x0, 0xc0]
   131  50  POP           [0xa, 0x45, 0xc0, 0x0]
   132  60  PUSH1         0x01  [0xa, 0x45, 0xc0]
   134  81  DUP2          [0xa, 0x45, 0xc0, 0x1]
   135  52  MSTORE        [0xa, 0x45, 0xc0, 0x1, 0xc0]
   136  51  MLOAD         [0xa, 0x45, 0xc0]
   137  90  SWAP1         [0xa, 0x45, 0x1]
   138  56  JUMP          [0xa, 0x1, 0x45]
    69  5b  JUMPDEST      [0xa, 0x1]
    70  90  SWAP1         [0xa, 0x1]
    71  56  JUMP          [0x1, 0xa]
    10  5b  JUMPDEST      [0x1]
    11  5f  PUSH0         [0x1]
    12  52  MSTORE        [0x1, 0x0]
    13  60  PUSH1         0x20  []
    15  5f  PUSH0         [0x20]
    16  f3  RETURN        [0x20, 0x0]
