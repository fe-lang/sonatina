#! evm.config: { stack_reach: 4 }
#! evm.case: ok
#!   calldata: u32be(11) u32be(22)
#!   expect: return u256(30)

target = "evm-ethereum-osaka"

func public %b(v0.i256) -> i256 {
    block0:
        v1.*i256 = alloca i256;
        mstore v1 v0 i256;
        v2.i256 = mload v1 i256;
        return v2;
}

func public %d(v0.i256) -> i256 {
    block0:
        v1.*i256 = alloca i256;
        mstore v1 v0 i256;
        v2.i256 = mload v1 i256;

        v3.i1 = eq v2 0.i256;
        br v3 block1 block2;

    block1:
        v4.i256 = call %b v2;
        return v4;

    block2:
        v5.*i256 = alloca i256;
        mstore v5 0.i256 i256;
        v6.i256 = mload v5 i256;

        v7.i256 = add v6 1.i256;
        v8.i256 = add v6 2.i256;
        v9.i256 = add v6 3.i256;
        v10.i256 = add v6 4.i256;
        v11.i256 = add v6 5.i256;

        v12.i256 = sub v2 1.i256;

        v13.i256 = call %d v12;

        v14.i256 = add v13 v7;
        v15.i256 = add v14 v8;
        v16.i256 = add v15 v9;
        v17.i256 = add v16 v10;
        v18.i256 = add v17 v11;
        return v18;
}

func public %a() -> i256 {
    block0:
        v0.i256 = call %d 2.i256;
        return v0;
}

func public %entry() {
    block0:
        v0.i256 = call %a;
        mstore 0.i32 v0 i256;
        evm_return 0.i8 32.i8;
}

object @Contract {
  section runtime {
    entry %entry;
  }
}
