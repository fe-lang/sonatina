#! SCCP companion simplifier: branch pruning enabled by simplification.

target = "evm-ethereum-london"

# sameln: func public %simplify_prune_branch(v0.i32) -> i32 {
# nextln:     block0:
# nextln:         return 2.i32;
func public %simplify_prune_branch(v0.i32) -> i32 {
    block0:
        v1.i32 = xor v0 v0;
        v2.i1 = ne v1 0.i32;
        br v2 block1 block2;

    block1:
        return 1.i32;

    block2:
        return 2.i32;
}

# sameln: func public %simplify_prune_branch_and_zero(v0.i32) -> i32 {
# nextln:     block0:
# nextln:         return 2.i32;
func public %simplify_prune_branch_and_zero(v0.i32) -> i32 {
    block0:
        v1.i32 = and v0 0.i32;
        v2.i1 = ne v1 0.i32;
        br v2 block1 block2;

    block1:
        return 1.i32;

    block2:
        return 2.i32;
}

# sameln: func public %simplify_prune_branch_mul_zero(v0.i32) -> i32 {
# nextln:     block0:
# nextln:         return 2.i32;
func public %simplify_prune_branch_mul_zero(v0.i32) -> i32 {
    block0:
        v1.i32 = mul v0 0.i32;
        v2.i1 = ne v1 0.i32;
        br v2 block1 block2;

    block1:
        return 1.i32;

    block2:
        return 2.i32;
}

# sameln: func public %simplify_prune_branch_or_all_one(v0.i32) -> i32 {
# nextln:     block0:
# nextln:         return 1.i32;
func public %simplify_prune_branch_or_all_one(v0.i32) -> i32 {
    block0:
        v1.i32 = or v0 -1.i32;
        v2.i1 = ne v1 0.i32;
        br v2 block1 block2;

    block1:
        return 1.i32;

    block2:
        return 2.i32;
}
